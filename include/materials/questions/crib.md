    bool - (логический тип)
    int - (целые числа)
    float - (дробные числа)
    string - (строки)
    array - (массивы)
    object - (объекты)
    callable - (функции)
    mixed - (любой тип)
    resource - (ресурсы)
    null - (отсутствие значения)

====================================================================================

    TCP/IP — Transmission Control Protocol/Internet Protocol
    UDP — User Datagram Protocol
    FTP — File Transfer Protocol
    HTTP — HyperText Transfer Protocol
    TLS (Transport Layer Security)
    SSL (Secure Socket Layer)
    DNS - Domain Name System
    NTP — Network Time Protocol
    SSH — Secure SHell
    IMAP, POP3, SMTP
    PSR (PHP Standards Recommendations)
    REST - REpresentational State Transfer
    SOAP Simple Object Access Protocol 
    JWT - JSON Web Token (JWT)


    YAGNI You Aren’t Gonna Need It / Вам это не понадобится
    DRY Don’t Repeat Yourself / Не повторяйтесь
    KISS Keep It Simple, Stupid / Будь проще
    BDUF Big Design Up Front Глобальное проектирование прежде всего
    APO Avoid Premature Optimization Избегайте преждевременной оптимизации

    SOLID

    S - Single Responsibility Principle
    O - Open closed Principle 
    L - Liskov substitution Principle
    I - Interface Segregation Principle
    D - Dependency Inversion Principl

====================================================================================

`Программируйте на основе интерфейса, а не его реализации`

Разные реализации можно скрыть за общим интерфейсом, определенным в суперклассе. В итоге появляется возможность
оперировать в клиентском коде объектом, относящимся к суперклассу,
а не к реализующему его классу, не особенно заботясь о его конкретной реализации.

`Связность`

Связность это степень, в которой соседние процедуры зависят одна от другой. В идеальном случае следует создавать
компоненты , в которых ответственность разделена совершенно четко и ясно.
Если по всему коду разбросаны связанные процедуры, то вскоре обнаружится, что их трудно сопровождать, потому что
придется прилагать усилия для поиска мест, где необходимо внести изменения.

`Тесная связь`

Тесная связь ( coupling ) возникает в том случае, когда отдельные части кода системы тесно связаны одна с другой, так
что изменение в одной части вызывает потребность вносить изменения в других частях.
Тесная связь не обязательно возникает в процедурном коде, но последовательный характер такого кода приводит к
определенным осложнениям.

`Повторное использование`

Повторное использование - одна из основных целей объектно-ориентированного проектирования , а тесная связь вредит этой
цели. Тесная связь возникает, когда изменение в одном компоненте системы
ведет к необходимости вносить множество изменений повсюду. Необходимо стремиться создавать независимые компоненты, чтобы
можно было вносить изменения, не опасаясь эффекта цепной реакции непредвиденных
последствий. Когда изменяется компонент, степень его независимости влияет на вероятность того, что эти изменения вызовут
ошибки в других частях системы.

`Ортогональность`

Ортогональность - Практически идеальное сочетание компонентов с четко определенными обязанностями наряду с
независимостью от более обширного контекста системы. Ортогональность способствует повторному использованию кода,
поскольку готовые компоненты можно
включать в новые системы без специальной их настройки. Такие компоненты должны иметь четко определенные входные и
выходные данные, независимые от какого- либо более обширного контекста.

`Композиция и наследование`

Наследование это эффективный способ описания меняющихся обстоятельств или контекста. Но из- за этого можно потерять в
гибкости, особенно если на классы возложено несколько функциональных обязанностей.
Композиция позволяет сделать код намного более гибким , поскольку можно комбинировать объекты и решать задачи
динамически намного большим количеством способов, чем при использовании одной лишь иерархии
наследования. Но при этом исходный код может стать неудобочитаемым. В результате композиции, как правило, создается
больше типов данных с отношениями , которые не настолько предсказуемы, как отношения
наследования. Поэтому понять отношения в такой системе немного труднее.

====================================================================================

`Инкапсуляция`

Инкапсуляция – это принцип, согласно которому любой класс и в более широком смысле – любая часть системы должны
рассматриваться как «черный ящик»: пользователь
класса или подсистемы должен видеть только интерфейс (т.е. список декларируемых свойств и методов) и не вникать во
внутреннюю реализацию.

Она позволяет минимизировать число связей между классами и подсистемами и, соответственно, упростить независимую
реализацию и модификацию классов и подсистем.

На самом элементарном уровне данные инкапсулируются путем объявления свойств как private или protected. Скрывая свойство
от клиентского кода, мы соблюдаем общий интерфейс и тем самым предотвращаем случайное повреждение данных объекта.

Таким образом, получается, что если класс A обращается к полям класса B напрямую, это приводит не к тому, что
«нарушается информационная безопасность», а к тому, что класс A завязывается на внутренне устройство класса B,
и попытка изменить внутреннее устройство класса B приведет к изменению класса А. Более того, класс A не просто так
работает с полями класса B, он работает по некоторой бизнес-логике. То есть логика по работе с состоянием
класса В лежит в классе А, и когда мы захотим переиспользовать класс В, это не удастся сделать, ведь без кусочка класса
А класс В может быть бесполезным, что приведет к тому, что класс В придется отдавать вместе с классом А.
Экстраполируя это на всю систему, получается, что переиспользовать можно будет только всю систему целиком.

`Наследование`

Наследование — это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (
суперкласса), добавляя при необходимости новые свойства иметоды.

Наследование является самым переоцененным принципом. Когда-то считалось, что «У идеального программиста дерево
наследования уходит в бесконечность и заканчивается абсолютно пустым объектом»,
потому как когда-то люди не очень хорошо понимали то, что наследование — это способ выразить такое свойство реального
мира как иерархичность, а не способ переиспользовать код, отнаследовав машину от холодильника,
потому что у обоих предметов есть ручка.

Наследования желательно по возможности избегать, потому что наследование является очень сильной связью. Для уменьшения
количества уровней наследования рекомендуется строить дерево «снизу-вверх».

`Полиморфизм`

Полиморфизм — это возможность использовать классы – потомки в контексте, который был предназначен для класса – предка.

Полиморфизм — это поддержка нескольких реализаций на основе общего интерфейса. О необходимости полиморфизма обычно
говорит наличие в коде большого количества условных операторов.

Полиморфизм - возможность для декомпозиции задачи и рефакторинга if'ов и switch'ей.

Если вы обнаружите, что проверяете некоторые условия в классе слишком часто, особенно если эти проверки повторяются в
нескольких методах, то, возможно, это сигнализирует о том, что один класс нужно разделить на два класса или более.
Выясните, не предполагает ли структура условного кода обязанности, которые можно выразить в отдельных классах. В этих
новых классах должны быть реализованы методы общего абстрактного базового класса. Вполне вероятно, что затем вам
придется найти способ передать нужный класс клиентскому коду.

В примере с интерфейсами – мы знаем, что объекты, реализовавшие какой-то интерфейс обязательно будут иметь метод с
определённым набором параметров. То есть мы можем рассчитывать на то, что этот метод у объекта гарантированно есть и мы
можем его вызвать.
Благодаря этому свойству объектов мы можем ожидать от них какого-то определенного поведения, если они являются объектами
какого-то класса или реализуют какой-то интерфейс.Это свойство, благодаря которому мы можем зависеть не от конкретной
реализации (проще говоря конкретного класса), а от абстракции (интерфейса), и есть – полиморфизм.

Полиморфизм демонстрирует другой вид инкапсуляции. Скрывая различные реализации за общим интерфейсом , мы прячем
основополагающие стратегии от клиентского кода. Это означает, что любые изменения , внесенные за этим интерфейсом,
являются прозрачными для более обширного контекста остальной системы. Мы можем ввести новые классы или изменить исходный
код в классе, и это не приведет к ошибкам. Значение имеет не интерфейс, а действующий за ним механизм.
Чем более независимы подобные механизмы, тем меньше вероятность, что внесенные изменения или поправки окажут эффект
цепной реакции на ваши проекты. В каком-то отношении инкапсуляция это ключ к объектно-ориентированному программированию.
Наша цель сделать каждую часть проектируемой системы как можно более независимой от остальных ее частей. Классы и методы
должны получать столько информации, сколько требуется для выполнения стоящих перед ними задач, которые должны быть
ограничены конкретными рамками и ясно определены.

====================================================================================

### Порождающие (Creational)

`Абстрактная фабрика (Abstract Factory)`

      Паттерн Abstract Factory предоставляет общий интерфейс для создания семейства взаимосвязанных объектов. Это позволяет отделить функциональность системы от внутренней реализации каждого класса,
      а обращение к этим классам становится возможным через абстрактные интерфейсы.
      В общем виде абстрактная фабрика выглядит следующим образом. Для каждого из семейств объектов, создается конкретная фабрика (наследник абстрактной), посредством которой создаются продукты этого семейства.

`Строитель (Builder)`

      Паттерн Builder определяет процесс поэтапного построения сложного продукта. После того как будет построена последняя его часть, продукт можно использовать.
      Одним из лучших применений паттерна Строитель является конструктор запросов SQL. Интерфейс Строителя определяет общие 
      шаги, необходимые для построения основного SQL-запроса. В тоже время Конкретные Строители, соответствующие различным 
      диалектам SQL, реализуют эти шаги, возвращая части SQL-запросов, которые могут быть выполнены в данном движке базы данных.

`Фабричный метод (Factory Method)`

      Паттерн Factory Method применяется для создания объектов с определенным интерфейсом, реализации которого предоставляются потомками. Другими словами, есть базовый абстрактный класс фабрики, 
      который говорит, что каждая его наследующая фабрика должна реализовать такой-то метод для создания своих продуктов.
      Реализация фабричного метода может быть разной, в большинстве случаем это зависит от языка реализации. Это может быть полиморфизм или параметризированный метод.
      Factory Method отличается от Abstract Factory, тем, что Abstract Factory производит семейство объектов, эти объекты разные, обладают разными интерфейсами, но взаимодействуют между собой. В то время как 
      Factory Method производит продукты придерживающиеся одного интерфейса и эти продукты не связаны между собой, не вступают во взаимодействие.
      Этот паттерн является «настоящим» Шаблоном Проектирования, потому что он следует «Принципу инверсии зависимостей» также известному как «D» в S.O.L.I.D.

`Объектный пул (Pool)`

      Порождающий паттерн, который предоставляет набор заранее инициализированных объектов, готовых к использованию («пул»), что не требует каждый раз создавать и уничтожать их.

`Прототип (Prototype)`

      Паттерн Prototype позволяет создавать новые объекты, путем копирования (клонирования) созданного ранее объекта-оригинала-продукта (прототипа).
      Помогает избежать затрат на создание объектов стандартным способом (new Foo()), а вместо этого создаёт прототип и затем клонирует его.

`Простая Фабрика (Simple Factory)`

      Она отличается от Статической Фабрики тем, что собственно не является статической. Таким образом, вы можете иметь множество фабрик с разными параметрами. Простая фабрика всегда должна быть предпочтительнее Статической фабрики!

`Одиночка (Singleton)`

      Паттерн контролирует создание единственного экземпляра некоторого класса и предоставляет доступ к нему.
      Другими словами, Singleton гарантирует, что у класса будет только один экземпляр и предоставляет к нему точку доступа, через фабричный метод.

`Статическая Фабрика (Static Factory)`

      Подобно AbstractFactory, этот паттерн используется для создания ряда связанных или зависимых объектов. Разница между этим шаблоном и Абстрактной Фабрикой заключается в том, что Статическая Фабрика использует 
      только один статический метод, чтобы создать все допустимые типы объектов. Этот метод, обычно, называется factory или build.

### Стуктурные (Structural)

`Адаптер (Adapter)`

      Часто в новом проекте разработчики хотят повторно использовать уже существующий код. Например, имеющиеся классы могут обладать нужной функциональностью и иметь при этом несовместимые интерфейсы. В таких 
      случаях следует использовать паттерн Adapter.
      Смысл работы этого паттерна в том, что если у вас есть класс и его интерфейс не совместим с кодом вашей системы, то что бы разрешить этот конфликт, мы не изменяем код этого класса, а пишем для 
      него адаптер. Другими словами Adapter адаптирует существующий код к требуемому интерфейсу (является переходником).

`Мост (Bridge)`

      Паттерн Bridge позволяет разделить объект на абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.
      Если для одной абстракции возможно несколько реализаций, то обычно используют наследование. Однако такой подход не всегда удобен, так как наследование жестко привязывает реализацию к абстракции, 
      что затрудняет независимую модификацию и усложняет их повторное использование.
      Паттерн следует применять, когда у нас имеется абстракция и несколько её реализаций. Разумеется, нет смысла отделять абстракцию от реализации, если реализация может быть только одна.

`Компоновщик (Composite)`

      Паттерн Composite группирует схожие объекты в древовидные структуры.
      Лист дерева является классом листовых узлов и не может иметь потомков (из листа не может вырасти ветвь или другой лист).
      Ветви дерева задают поведение объектов, входящих в структуру дерева, у которых есть потомки, а также сами хранит в себе компоненты дерева. Другим словами ветви могут содержать другие ветви и листья.

`Преобразователь Данных (Data Mapper)`

      Это паттерн, который выступает в роли посредника для двунаправленной передачи данных между постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, 
      то что уже загружено и используется для логической обработки). Цель паттерна в том, чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от 
      самого преобразователя данных.
      Ключевым моментом этого паттерна, в отличие от Активной Записи (Active Records) является то, что модель данных следует Принципу Единой Обязанности SOLID.

`Декоратор (Decorator)`

      Паттерн Decorator используется для расширения функциональности объектов путем динамического добавления объекту новых возможностей. При реализации паттерна используется отношение композиции.
      Сущность работы декоратора заключается в обёртывании готового объекта новым функционалом, при этом весь оригинальный интерфейс объекта остается доступным, путем передачи декоратором всех 
      запросов обернутому объекту.

`Внедрение Зависимости (Dependency Injection)`

      Для реализации слабосвязанной архитектуры. Чтобы получить более тестируемый, сопровождаемый и расширяемый код.

`Фасад (Facade)`

      Паттерн Facade предоставляет высокоуровневый унифицированный интерфейс в виде набора имен методов к набору взаимосвязанных классов или объектов некоторой подсистемы, что облегчает ее использование.
      Разбиение сложной системы на подсистемы позволяет упростить процесс разработки, а также помогает максимально снизить зависимости одной подсистемы от другой. Однако использовать такие подсистемы 
      становиться довольно сложно. Один из способов решения этой проблемы является паттерн Facade. Наша задача, сделать простой, единый интерфейс, через который можно было бы взаимодействовать с подсистемами.

`Текучий Интерфейс (Fluent Interface)`

      Писать код, который легко читается, как предложения в естественном языке (вроде русского или английского).
      Doctrine2’s QueryBuilder работает примерно также.
      PHPUnit использует текучий интерфейс, чтобы создавать макеты объектов.

`Приспособленец (Flyweight)`

      Паттерн Flyweight используется для эффективной поддержки большого числа мелких объектов, он позволяет повторно использовать мелкие объекты в различном контексте.
      Суть в том, что мы можем запрашивать приспособленцев у фабрики(модифицированный паттерн фабрики, для создания приспособленцев) по запросу, в свою очередь она будет отдавать те объекты, которые уже 
      были созданы, или создавать новые. Это означает, что мы будем использовать уже созданные объекты, а не создавать ещё больше, если объекты под наши нужны уже имеются.

`Прокси (Proxy)`

      Паттерн Proxy предоставляет объект для контроля доступа к другому объекту.
      Proxy предоставляет своему объекту тот же интерфейс. Adapter предоставляет другой интерфейс. Decorator предоставляет расширенный интерфейс.
      Паттерну Proxy выдвигается ряд важных требований, а именно то, что оригинальный объект и его суррогат должны взаимодействовать друг с другом, а также должна быть возможность, замещения оригинальным 
      объектом, суррогата в месте его использования, соответственно интерфейсы взаимодействия оригинального объекта и его суррогата должны совпадать.
      Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны 
      наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.

`Реестр (Registry)`

      Для реализации централизованного хранения объектов, часто используемых во всем приложении, как правило, реализуется с помощью абстрактного класса только c статическими методами (или с помощью 
      шаблона Singleton). Помните, что это вводит глобальное состояние, которого следует избегать. Используйте Dependency Injection вместо Registry.

### Поведенческие (Behavioral)

`Цепочка ответственности (Chain Of Responsibility)`

      Паттерн Chain Of Responsibility позволяет избежать привязки объекта-отправителя запроса к объекту-получателю запроса, при этом давая шанс обработать этот запрос нескольким объектам. Получатели 
      связываются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-то объектом.
      По сути это цепочка обработчиков, которые по очереди получают запрос, а затем решают, обрабатывать его или нет. Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то 
      паттерн сам решает передавать его дальше или нет. Если запрос не обработан ни одним обработчиком, то он просто теряется.

`Команда (Command)`

      Паттерн Command позволяет представить запрос в виде объекта. Из этого следует, что команда - это объект. Такие запросы, например, можно ставить в очередь, отменять или возобновлять
      В этом паттерне мы оперируем следующими понятиями: Command - запрос в виде объекта на выполнение; Receiver - объект-получатель запроса, который будет обрабатывать нашу команду; Invoker - объект-инициатор
      запроса.

` Интепретатор (Interpreter)`

      Для некоего языка шаблон описывает его грамматику с помощью терминов «Терминальный символ» и «Нетерминальный символ», а также описывает интерпретатор предложений, созданных с помощью данного языка.
      Интерпретатор бинарной (двоичной) логики, в котором каждый тип логической операции определен в своем собственном классе.

`Итератор (Iterator)`

      Паттерн Iterator предоставляет механизм обхода коллекций объектов не раскрывая их внутреннего представления.
      Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой.

`Посредник (Mediator)`

      Паттерн Mediator предоставляет объект-посредник, скрывающий способ взаимодействия множества других объектов-коллег. Mediator делает систему слабо связанной, избавляя объекты от необходимости ссылаться 
      друг на друга, что позволяет изменять взаимодействие между ними независимо.
      Например, у нас есть посредник между заводом производства хлебобулочных изделий, фермером и магазином сбыта. Посредник избавляет фермера от взаимодействия с заводом, который использует его сырье, а 
      завод от взаимодействия с магазином, в который поступает продукция для сбыта.

`Хранитель (Memento)`

      Паттерн Memento получает и сохраняет за пределами объекта его внутреннее состояние так, чтобы позже можно было восстановить объект в таком же состоянии. Если клиенту в дальнейшем нужно "откатить" 
      состояние исходного объекта, он передает Memento обратно в исходный объект для его восстановления.

`Объект Null (Null Object)`

      NullObject не шаблон из книги Банды Четырёх, но схема, которая появляется достаточно часто, чтобы считаться паттерном. Она имеет следующие преимущества:
      Клиентский код упрощается
      Уменьшает шанс исключений из-за нулевых указателей (и ошибок PHP различного уровня)
      Меньше дополнительных условий — значит меньше тесткейсов

      Методы, которые возвращают объект или Null, вместо этого должны вернуть объект NullObject. Это упрощённый формальный код, устраняющий необходимость проверки 
      if (!is_null($obj)) { $obj->callSomething(); }, заменяя её на обычный вызов $obj->callSomething();.

`Наблюдатель (Observer)`

      Паттерн Observer определяет зависимость "один-ко-многим" между объектами так, что при изменении состояния одного объекта все зависящие от него объекты уведомляются об этом и обновляются автоматически.
      Основные участиники паттерна это Издатели (Subject) и Подписчики (Observer).
      Например: Система очереди сообщений наблюдает за очередями, чтобы отображать прогресс в GUI

`Спецификация (Specification)`

      Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. Композитный класс спецификация имеет один метод, называемый isSatisfiedBy, который возвращает истину
      или ложь в зависимости от того, удовлетворяет ли данный объект спецификации.

`Состояние (State)`

      Паттерн State позволяет объекту изменять свое поведение в зависимости от внутреннего состояния и является объектно-ориентированной реализацией конечного автомата. Поведение объекта изменяется на столько, 
      что создается впечатление, что изменился класс объекта.
      Паттерн должен применятся, когда поведение объекта зависит от его состояния и оно должно изменяться во время выполнения программы при условии того, что состояний достаточно много и использовать для 
      этого условные операторы разбросаные по коду достаточно затруднительно.
      Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя 
      ему часть своей работы. Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.
      Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.
      Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании. Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь дублирующий код.

`Стратегия (Strategy)`

      Паттерн Strategy определяет набор алгоритмов схожих по роду деятельности, инкапсулирует их в отдельный класс и делает их подменяемыми. Паттерн Strategy позволяет подменять алгоритмы без участия клиентов, 
      которые используют эти алгоритмы.
      Стратегия позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).
      Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.
      Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри классов-стратегий.

`Шаблонный метод (Template Method)`

      Паттерн Template Method формирует структуру алгоритма и позволяет в производных классах реализовать, перекрыть или переопределить определенные шаги алгоритма, не изменяя структуру алгоритма в целом.
      Проектировщик решает, какие шаги алгоритма являются неизменными, а какие изменяемыми. Абстрактный базовый класс реализует стандартные неизменяемые шаги алгоритма и может предоставлять реализацию по 
      умолчанию для изменяемых шагов. Изменяемые шаги могут предоставляться клиентом компонента в конкретных производных классах.
      Возможно, вы сталкивались с этим уже много раз. Идея состоит в том, чтобы позволить наследникам абстрактного шаблона переопределить поведение алгоритмов родителя.
      Другими словами, это каркас алгоритма, который хорошо подходит для библиотек (в фреймворках, например). Пользователь просто реализует уточняющие методы, а суперкласс делает всю основную работу.
      Это простой способ изолировать логику в конкретные классы и уменьшить копипаст, поэтому вы повсеместно встретите его в том или ином виде.

`Посетитель (Visitor)`

      Паттерн Visitor позволяет обойти набор элементов (объектов) с разнородными интерфейсами, а также позволяет добавить новый метод в класс объекта, при этом, не изменяя сам класс этого объекта.
      Шаблон «Посетитель» выполняет операции над объектами других классов. Главной целью является сохранение разделения направленности задач отдельных классов. При этом классы обязаны определить специальный 
      контракт, чтобы позволить использовать их Посетителям (метод «принять роль» Role::accept в примере).
      Контракт, как правило, это абстрактный класс, но вы можете использовать чистый интерфейс. В этом случае, каждый посетитель должен сам выбирать, какой метод ссылается на посетителя.

### Дополнительно

`Локатор Служб (Service Locator)`

      Некоторые считают Локатор Служб анти-паттерном. Он нарушает принцип инверсии зависимостей (Dependency Inversion principle) из набора принципов SOLID. Локатор Служб скрывает зависимости данного класса 
      вместо их совместного использования, как в случае шаблона Внедрение Зависимости (Dependency Injection). В случае изменения данных зависимостей мы рискуем сломать функционал классов, которые их 
      используют, вследствие чего затрудняется поддержка системы.
      С Локатором Служб вы можете зарегистрировать сервис для определенного интерфейса. С помощью интерфейса вы можете получить зарегистрированный сервис и использовать его в классах приложения, не зная 
      его реализацию. Вы можете настроить и внедрить объект Service Locator на начальном этапе сборки приложения.

`Хранилище (Repository)`

      Посредник между уровнями области определения (хранилище) и распределения данных. Использует интерфейс, похожий на коллекции, для доступа к объектам области определения. Репозиторий инкапсулирует набор 
      объектов, сохраняемых в хранилище данных, и операции выполняемые над ними, обеспечивая более объектно-ориентированное представление реальных данных. Репозиторий также преследует цель достижения 
      полного разделения и односторонней зависимости между уровнями области определения и распределения данных.

`Сущность-Атрибут-Значение (Attribute)`

      Модель Сущность-Атрибут-Значение (EAV) - это модель данных, предназначенная для описания сущностей, в которых количество атрибутов (свойств, параметров), характеризующих их, потенциально огромно, но 
      то количество, которое реально будет использоваться в конкретной сущности, относительно мало.
