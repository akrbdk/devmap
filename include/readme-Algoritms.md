###ALGORITMS

#### Список ссылок

- [Сравнение алгоритмов сортировки](https://habr.com/ru/post/274017/)
- [Описание алгоритмов сортировки и сравнение их производительности](https://habr.com/ru/post/335920/)
- [Сортировка массивов](https://ru.hexlet.io/courses/php-arrays/lessons/sorting/theory_unit)
- [Bubble Sort Visualization](https://zenozeng.github.io/bubble-sort-visualization/)
- [Comparison Sorting Algorithms](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)


### Алгоритмы  [&uarr;](#PHP)

Мы смело оперируем фабриками, синглтонами и декораторами, но забываем о такой фундаментальной части программирования, как 
классические алгоритмы. Ведь если присмотреться к их реализации, то это тоже своего рода паттерны. С институтской скамьи 
можно вспомнить, к примеру, nested sets, b-tree, сортировку «пузырьком». Реализация многих алгоритмов давно устоялась.

### Рекурсия

В общем смысле `рекурсия` это отображение чего-либо внутри самого себя. Рекурсивные алгоритмы используют рекурсивные функции, 
обладающие данным свойством.

Полезное практическое применение рекурсии — увидел в сортировке и преобразовании массивов деревьев.

Существует два варианта реализации рекурсивных функций: простой и сложный:

- В `простом` случае рекурсивная функция вызывает саму себя. 
- В `сложном` — функция вызывает другую функцию, которая вызывает исходную функцию, с которой всё начиналось.

Рассмотрим пример из жизни. Если взять два больших зеркала и поставить их друг напротив друга, то можно увидеть бесконечный коридор 
из изображений зеркал. Каждое зеркало несёт в себе функцию отражения пространства расположенного перед ним. Поэтому здесь мы имеем 
пример сложной рекурсии (функция вызывает другую функцию, которая вызывает исходную).

`Глубина рекурсии` - в связи с понятием рекурсии возникает понятие глубины рекурсии, то есть степени вложенности её отображений. Глубина 
рекурсии может быть равна бесконечности, в этом случае говорят о бесконечной рекурсии - в реальных условиях запуск программы приведёт 
к Segmentation fault, так как произойдёт переполнение стека вызова в силу ограничений на выделенную под него память. Понимая это следует 
избегать таких конструкций при разработке. В PHP функции не могут вызывать друг друга бесконечно, так как это неизбежно приведёт 
к падению программы. Рекурсивный вызов должен завершиться по достижении степени вложенности n.


#### Рекурсивные алгоритмы на PHP

 - Нахождение факториала
 - Вычисление последовательности Фибоначчи
 - Поиск максимального элемента в массиве
 - Вычисление перестановок Ханойских башен
 - Рассчёт вариантов размена суммы монетами
 - Рекурсивный обход дерева


### Сравнение алгоритмов сортировки [&uarr;](#devmap)

`Сортировка массивов` — самая базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. С другой
стороны, в реальном коде массивы сортируют, используя уже готовые функции стандартной библиотеки. Тогда для чего задают
подобные вопросы? Обычно собеседующий хочет узнать следующее:

- Насколько вы вообще в курсе о существовании алгоритмов.
- Способны ли вы программировать.
- Как работает ваше алгоритмическое мышление.

Виды алгоритмов сортировки:

- `Selection sort (сортировка выбором)` – суть алгоритма заключается в проходе по массиву от начала до конца в поиске минимального 
элемента массива и перемещении его в начало. Сложность такого алгоритма O(n2).

- `Bubble sort (сортировка пузырьком)` – данный алгоритм меняет местами два соседних элемента, если первый элемент массива 
больше второго. Так происходит до тех пор, пока алгоритм не обменяет местами все неотсортированные элементы. Сложность 
данного алгоритма сортировки равна O(n^2).

- `Insertion sort (сортировка вставками)` – алгоритм сортирует массив по мере прохождения по его элементам. На каждой итерации 
берется элемент и сравнивается с каждым элементом в уже отсортированной части массива, таким образом находя «свое место», после 
чего элемент вставляется на свою позицию. Так происходит до тех пор, пока алгоритм не пройдет по всему массиву. На выходе 
получим отсортированный массив. Сложность данного алгоритма равна O(n^2).

- `Quick sort (быстрая сортировка)` – суть алгоритма заключается в разделении массива на два под-массива, средней линией считается 
элемент, который находится в самом центре массива. В ходе работы алгоритма элементы, меньшие чем средний будут перемещены в лево, 
а большие в право. Такое же действие будет происходить рекурсивно и с под-массива, они будут разделяться на еще два под-массива 
до тех пор, пока не будет чего разделать (останется один элемент). На выходе получим отсортированный массив. Сложность алгоритма 
зависит от входных данных и в лучшем случае будет равняться O(n×2log2n). В худшем случае O(n^2). Существует также среднее значение, 
это O(n×log2n).

- `Comb sort (сортировка расческой)` – идея работы алгоритма крайне похожа на сортировку обменом, но главным отличием является то, 
что сравниваются не два соседних элемента, а элементы на промежутке, к примеру, в пять элементов. Это обеспечивает от избавления 
мелких значений в конце, что способствует ускорению сортировки в крупных массивах. Первая итерация совершается с шагом, рассчитанным 
по формуле (размер массива)/(фактор уменьшения), где фактор уменьшения равен приблизительно 1,247330950103979, или округлено до 1,3. 
Вторая и последующие итерации будут проходить с шагом (текущий шаг)/(фактор уменьшения) и будут происходить до тех пор, пока шаг не 
будет равен единице. Практически в любом случае сложность алгоритма равняется O(n×log2n).


Для сортировки неотсортированного массива, наиболее оптимальным из представленных алгоритмов для сортировки массива
является `быстрая сортировка`. Несмотря на более длительное время выполнения алгоритм потребляет меньше памяти, что может
быть важным в крупных проектах.

Однако такие алгоритмы как `сортировка выбором`, `обменом` и `вставками` могут лучше подойти для научных целей, например, в
обучении, где не нужно обрабатывать огромное количество данных.

При частично отсортированном массиве результаты не сильно отличаются, все алгоритмы сортировки показывают время примерно
на 2-3 миллисекунды меньше. Однако при сортировке частично отсортированного массива `быстрая сортировка` срабатывает
намного быстрее и потребляет меньшее количество памяти.

Пример пузырьковой сортировки^

    <?php

    function bubbleSort($coll)
    {
        $size = count($coll);
        // do..while цикл. Работает почти идентично while
        // Разница в проверке. Тут она делается не до выполнения тела, а после.
        // Такой цикл полезен там, где надо выполнить тело хотя бы раз в любом случае.
        do {
            // Объявляем переменную swapped, значение которой показывает был ли
            // совершен обмен элементов во время перебора массива
            $swapped = false;
            // Перебираем массив и меняем местами элементы, если предыдущий
            // больше, чем следующий
            for ($i = 0; $i < $size - 1; $i++) {
                if ($coll[$i] > $coll[$i + 1]) {
                    // temp – временная переменная для хранения текущего элемента
                    $temp = $coll[$i];
                    $coll[$i] = $coll[$i + 1];
                    $coll[$i + 1] = $temp;
                    // Если сработал if и была совершена перестановка,
                    // присваиваем swapped значение true
                    $swapped = true;
                }
            }
            // Уменьшаем счетчик на 1, т.к. самый большой элемент уже находится
            // в конце массива
            $size--;
        } while ($swapped); // продолжаем, пока swapped === true

        return $coll;
    }

    print_r(bubbleSort([3, 2, 10, -2, 0]));
    // => Array
    // => (
    // =>     [0] => -2
    // =>     [1] => 0
    // =>     [2] => 2
    // =>     [3] => 3
    // =>     [4] => 10
    // => )


### Структуры данных [&uarr;](#Other-tasks)

Структуры данных — программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных 
в вычислительной технике. Данные можно представить по-разному. В зависимости от того, что это за данные и что вы собираетесь с ними делать, 
одно представление подойдёт лучше других.

Рекомендуется ознакомиться с алгоритмами хотя бы на базововом уровне. Так как структуры данных реализованы с помощью алгоритмов,
алгоритмы - с помощью структур данных.

- Списки
- Хеш-таблица
- Стек
- Очередь
- Граф
- Связный список
- Деревья
- Двоичное дерево поиска

В разделе PHP ранее были описаны некоторые структуры данных:

- [x] [SPL классы](readme-Learn-a-Language-PHP.md#SPL-классы-)
- [x] [Какие структуры данных вы знаете?](readme-Learn-a-Language-PHP.md#Какие-структуры-данных-вы-знаете?-)
- [x] [Разница стэка и очереди.](readme-Learn-a-Language-PHP.md#Разница-стэка-и-очереди.-)



### Некоторые вопросы по алгоритмам


Структуры данных

1. Разница между Array (массивом) и LinkedList (связным списком)
2. Принцип работы массивов, списков, словарей и использовать их для решения практических задач
3. Какие компромиссы между объёмом занимаемой памяти и быстродействием имеют место в базовых структурах данных, какие операции и почему легче выполнять для массивов, а какие — для списков. Нужно привести и объяснить способы реализации хеш-таблиц и разрешений коллизий в них. Приоритетные очереди и способы их реализации.
4. Знать и понимать продвинутые структуры данных: B-деревья, биномиальные и фибоначчи-кучи, красно-чёрных деревья, «выворачивающиеся» (Splay) деревья, слоёные списки (skip lists), префиксные и суффиксные деревья и т.п.

Алгоритмы

1. Найти среднее значение чисел в массиве
2. Знать основные алгоритмы сортировки, поиска, обхода и выборки даннных.
3. Деревья и Графы. Простые «жадные » алгоритмы и алгоритмы вида «разделяй-и-властвуй» (вроде QuickSort). Необходимо понять смысл обозначения уровней в этой матрице.
4. Распознать и программно решить задачи динамического программирования, хорошо знать алгоритмы работы с графами, вычислительные алгоритмы. Распознать класс сложности задачи и т.п.






