###ALGORITMS


* [ ] [Алгоритмы. Какие использовал?](#Алгоритмы.-Какие-использовал?)
* [ ] [Сравнение алгоритмов сортировки](#Сравнение-алгоритмов-сортировки-)


###ALGORITMS

### Алгоритмы. Какие использовал?  [&uarr;](#PHP)

Мы смело оперируем фабриками, синглтонами и декораторами, но забываем о такой фундаментальной части программирования, как классические алгоритмы. Ведь если присмотреться к их реализации, то это тоже своего рода паттерны. С институтской скамьи можно вспомнить, к примеру, nested sets, b-tree, сортировку «пузырьком». Реализация многих алгоритмов давно устоялась.

Понятие рекурсии

    Для начала разберёмся с понятием рекурсии. В общем смысле рекурсия это отображение чего-либо внутри самого себя. Рекурсивные алгоритмы используют рекурсивные функции, обладающие данным свойством.

    Полезное практическое применение рекурсии — увидел в сортировке и преобразовании массивов деревьев.

    Существует два варианта реализации рекурсивных функций: простой и сложный. В простом случае рекурсивная функция вызывает саму себя. В сложном — функция вызывает другую функцию, которая вызывает исходную функцию, с которой всё начиналось.

Рассмотрим пример из жизни. Если взять два больших зеркала и поставить их друг напротив друга, то можно увидеть бесконечный коридор из изображений зеркал. Каждое зеркало несёт в себе функцию отражения пространства расположенного перед ним. Поэтому здесь мы имеем пример сложной рекурсии (функция вызывает другую функцию, которая вызывает исходную).

Глубина рекурсии

    В связи с понятием рекурсии возникает понятие глубины рекурсии, то есть степени вложенности её отображений. 

    В связи с понятием рекурсии возникает понятие глубины рекурсии, то есть степени вложенности её отображений. 
    
    Матрёшка, как правило, имеет 3-х и более вложенных в неё матрёшек. То есть глубина рекурсии в данном случае равна количеству вложенных матрёшек. 
    
    Глубина рекурсии может быть равна бесконечности, в этом случае говорят о бесконечной рекурсии - в реальных условиях запуск программы приведёт к Segmentation fault, так как произойдёт переполнение стека вызова в силу ограничений на выделенную под него память. Понимая это следует избегать таких конструкций при разработке.

    В PHP функции не могут вызывать друг друга бесконечно, так как это неизбежно
    приведёт к падению программы.

    Рекурсивный вызов должен завершиться по достижении степени вложенности n.

Рекурсивные алгоритмы на PHP

    Нахождение факториала
    Вычисление последовательности Фибоначчи
    Поиск максимального элемента в массиве
    Вычисление перестановок Ханойских башен
    Рассчёт вариантов размена суммы монетами
    Рекурсивный обход дерева
    и т.д.


### Сравнение алгоритмов сортировки [&uarr;](#devmap)

Сортировка массивов — самая базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. С другой
стороны, в реальном коде массивы сортируют, используя уже готовые функции стандартной библиотеки. Тогда для чего задают
подобные вопросы? Обычно собеседующий хочет узнать следующее:

1) Насколько вы вообще в курсе о существовании алгоритмов.
2) Способны ли вы программировать.
3) Как работает ваше алгоритмическое мышление.

   Selection sort (сортировка выбором) – суть алгоритма заключается в проходе по массиву от начала до конца в поиске минимального элемента массива и перемещении его в начало. Сложность такого алгоритма O(n2).

   Bubble sort (сортировка пузырьком) – данный алгоритм меняет местами два соседних элемента, если первый элемент массива больше второго. Так происходит до тех пор, пока алгоритм не обменяет местами все неотсортированные элементы. Сложность данного алгоритма сортировки равна O(n^2).

   Insertion sort (сортировка вставками) – алгоритм сортирует массив по мере прохождения по его элементам. На каждой итерации берется элемент и сравнивается с каждым элементом в уже отсортированной части массива, таким образом находя «свое место», после чего элемент вставляется на свою позицию. Так происходит до тех пор, пока алгоритм не пройдет по всему массиву. На выходе получим отсортированный массив. Сложность данного алгоритма равна O(n^2).

   Quick sort (быстрая сортировка) – суть алгоритма заключается в разделении массива на два под-массива, средней линией считается элемент, который находится в самом центре массива. В ходе работы алгоритма элементы, меньшие чем средний будут перемещены в лево, а большие в право. Такое же действие будет происходить рекурсивно и с под-массива, они будут разделяться на еще два под-массива до тех пор, пока не будет чего разделать (останется один элемент). На выходе получим отсортированный массив. Сложность алгоритма зависит от входных данных и в лучшем случае будет равняться O(n×2log2n). В худшем случае O(n^2). Существует также среднее значение, это O(n×log2n).

   Comb sort (сортировка расческой) – идея работы алгоритма крайне похожа на сортировку обменом, но главным отличием является то, что сравниваются не два соседних элемента, а элементы на промежутке, к примеру, в пять элементов. Это обеспечивает от избавления мелких значений в конце, что способствует ускорению сортировки в крупных массивах. Первая итерация совершается с шагом, рассчитанным по формуле (размер массива)/(фактор уменьшения), где фактор уменьшения равен приблизительно 1,247330950103979, или округлено до 1,3. Вторая и последующие итерации будут проходить с шагом (текущий шаг)/(фактор уменьшения) и будут происходить до тех пор, пока шаг не будет равен единице. Практически в любом случае сложность алгоритма равняется O(n×log2n).

Для сортировки неотсортированного массива, наиболее оптимальным из представленных алгоритмов для сортировки массива
является быстрая сортировка. Несмотря на более длительное время выполнения алгоритм потребляет меньше памяти, что может
быть важным в крупных проектах.

Однако такие алгоритмы как сортировка выбором, обменом и вставками могут лучше подойти для научных целей, например, в
обучении, где не нужно обрабатывать огромное количество данных.

При частично отсортированном массиве результаты не сильно отличаются, все алгоритмы сортировки показывают время примерно
на 2-3 миллисекунды меньше. Однако при сортировке частично отсортированного массива быстрая сортировка срабатывает
намного быстрее и потребляет меньшее количество памяти.

Пример пузырьковой сортировки

    <?php

    function bubbleSort($coll)
    {
        $size = count($coll);
        // do..while цикл. Работает почти идентично while
        // Разница в проверке. Тут она делается не до выполнения тела, а после.
        // Такой цикл полезен там, где надо выполнить тело хотя бы раз в любом случае.
        do {
            // Объявляем переменную swapped, значение которой показывает был ли
            // совершен обмен элементов во время перебора массива
            $swapped = false;
            // Перебираем массив и меняем местами элементы, если предыдущий
            // больше, чем следующий
            for ($i = 0; $i < $size - 1; $i++) {
                if ($coll[$i] > $coll[$i + 1]) {
                    // temp – временная переменная для хранения текущего элемента
                    $temp = $coll[$i];
                    $coll[$i] = $coll[$i + 1];
                    $coll[$i + 1] = $temp;
                    // Если сработал if и была совершена перестановка,
                    // присваиваем swapped значение true
                    $swapped = true;
                }
            }
            // Уменьшаем счетчик на 1, т.к. самый большой элемент уже находится
            // в конце массива
            $size--;
        } while ($swapped); // продолжаем, пока swapped === true

        return $coll;
    }

    print_r(bubbleSort([3, 2, 10, -2, 0]));
    // => Array
    // => (
    // =>     [0] => -2
    // =>     [1] => 0
    // =>     [2] => 2
    // =>     [3] => 3
    // =>     [4] => 10
    // => )

