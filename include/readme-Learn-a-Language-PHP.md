
#### Список ссылок

- [PHP — эволюция синтаксиса](https://wp-kama.ru/id_6310/php-evolution.html#php-8-1)
- [PHP: Список изменений](https://www.php.net/manual/ru/doc.changelog.php)
- [PHP Versions](https://php.watch/versions)
- [PHP | endoflife.date](https://endoflife.date/php)
- [Что нового в PHP 8.0](https://www.php.net/releases/8.0/ru.php)
- [Что нового в PHP 8.1](https://www.php.net/releases/8.1/ru.php)
- [Что нового в PHP 8.2](https://www.php.net/releases/8.2/ru.php)
- [Вышел PHP 8.2: разбираем главные изменения](https://habr.com/ru/company/hexlet/blog/705194/)


- [Справочник языка ¶](https://www.php.net/manual/ru/langref.php)
- [PHP Reflection API](https://php.zone/oop-v-php-prodvinutyj-kurs/php-reflection-api-uchimsya-primenyat)
- [Лекция-дайджест по PHP SPL](https://devenergy.ru/archives/288)


- [Структуры данных(на примере PHP SPL)](https://medium.com/@alexawesome/%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5-php-spl-9a98bc08b6c0)
- [Структуры данных](https://www.php.net/manual/ru/spl.datastructures.php)
- [Обработка исключений и ошибок в PHP](https://maxsite.org/page/exception-in-php)
- [Анонимные функции](https://www.php.net/manual/ru/functions.anonymous.php)
- [Псевдотипы и переменные, используемые в этой документации](http://php.adamharvey.name/manual/ru/language.pseudo-types.php)
- [Асинхронность, конкурентность, параллельность, многопоточность — разбираемся «по понятиям» :)](https://habr.com/ru/post/667590/)
- [Как использовать AJAX в PHP и jQuery](https://code.tutsplus.com/ru/tutorials/how-to-use-ajax-in-php-and-jquery--cms-32494)
- [Синтаксис генераторов](https://www.php.net/manual/ru/language.generators.syntax.php)
- [Реальные примеры использования генераторов в PHP](https://badtry.net/primiery-ispolzovaniia-ghienieratorov-v-php/)
- [Event-driven архитектура (она же событийно-ориентированная)](https://habr.com/ru/post/699492/)


- [Всё, что вы хотели узнать об интерфейсах, совместимости сигнатур](https://habr.com/ru/post/328890/)
- [Принципы объектно-ориентированного программирования](https://habr.com/ru/company/otus/blog/525336/)
- [ООП в PHP](https://maxsite.org/page/php-oop)
- [Область видимости переменной](https://www.php.net/manual/ru/language.variables.scope.php)
- [Область видимости свойства, метода или константы](https://www.php.net/manual/ru/language.oop5.visibility.php)
- [PHP: Интерфейсы vs Абстрактные классы](https://www.dev-notes.ru/articles/interfaces-vs-abstract-classes-in-php/)
- [Перегрузка](https://www.php.net/manual/ru/language.oop5.overloading.php)
- [Конструкторы и деструкторы](https://www.php.net/manual/ru/language.oop5.decon.php)
- [Трейты](https://www.php.net/manual/ru/language.oop5.traits.php)
- [PHP: ключевое слово «static»](https://habr.com/ru/post/259627/)
- [Анонимные классы](http://micmap.org/php-by-example/manual/ru/language.oop5.anonymous.html)



### PHP: Hypertext Preprocessor (or simply PHP)

* [ ] [PHP versions](#PHP-versions-) //todo дописать
* [ ] [Reflection API](#Reflection-API-)
* [ ] [Что такое PEAR и PECL?](#Что-такое-PEAR-и-PECL?)
* [ ] [Обработка ошибок](#Обработка-ошибок)
* [ ] [Типы данных в PHP](#Типы-данных-в-PHP)
* [ ] [Псевдотипы](#Псевдотипы)
* [ ] [Анонимные функции, замыкания](#Анонимные-функции,-замыкания)
* [ ] [Назовите 5 различных функций для работы с массивами.](#Назовите-5-различных-функций-для-работы-с-массивами.)
* [ ] [Функции сортировки массивов - несколько штук](#Функции-сортировки-массивов---несколько-штук)
* [ ] [!empty() vs isset()](#!empty()-vs-isset())
* [ ] [отличие include от require.](#отличие-include-от-require.)


###ПРОЕКТИРОВАНИЕ

* [ ] [Что такое MVC и какие преимущества его использования?](#Что-такое-MVC-и-какие-преимущества-его-использования?-)
* [ ] [логика в контроллере, должна ли быть и почему](#логика-в-контроллере,-должна-ли-быть-и-почему)


###СТРУКТУРЫ ДАННЫХ

* [ ] [SPL классы](#SPL-классы)
* [ ] [Какие структуры данных вы знаете?](#Какие-структуры-данных-вы-знаете?-)
* [ ] [Разница стэка и очереди.](#Разница-стэка-и-очереди.)


###DB

* [ ] [Знакомы ли с ORM, ActiveRecord?](#Знакомы-ли-с-ORM,-ActiveRecord?)
* [ ] [что такое PDO и подготовленные запросы](#что-такое-PDO-и-подготовленные-запросы)


###ООП

* [ ] [3 принципа ООП.](#3-принципа-ООП.)
* [ ] [Особенности ООП в PHP.](#Особенности-ООП-в-PHP.)
* [ ] [Области видимости](#Области-видимости)
* [ ] [Чем интерфейс отличается от абстрактного класса?](#Чем-интерфейс-отличается-от-абстрактного-класса?)
* [ ] [Несколько конструкторов в классе](#Несколько-конструкторов-в-классе)
* [ ] [Трейты - зачем](#Трейты---зачем)
* [ ] [Можно ли сделать множестенное наследование в PHP](#Можно-ли-сделать-множестенное-наследование-в-PHP)
* [ ] [Статические свойства и методы](#Статические-свойства-и-методы)

### Асинхронность, конкурентность, параллельность, многопоточность в PHP

* [ ] [Асинхронность, конкурентность, параллельность, многопоточность в PHP](#Асинхронность,-конкурентность,-параллельность,-многопоточность-в-PHP)
* [ ] [Event loop - цикл событий](#Event-loop---цикл-событий)
* [ ] [Event-driven в Symfony - это асинхронность?](#Event-driven-в-Symfony---это-асинхронность?)
* [ ] [Распределенная асинхронность](#Распределенная-асинхронность)
* [ ] [Кооперативная многозадачность на примере генераторов и корутин](#Кооперативная-многозадачность-на-примере-генераторов-и-корутин)
* [ ] [yield](#yield)
* [ ] [Корутины](#Корутины)
* [ ] [Файберы](#Файберы)
* [ ] [Проблема блокирующего кода](#Проблема-блокирующего-кода)
* [ ] [Реальное параллельное исполнение - процессы](#Реальное-параллельное-исполнение---процессы)
* [ ] [Многопоточность](#Многопоточность)
* [ ] [Swoole и его go-рутины](#Swoole-и-его-go-рутины)


#OTHER

### PHP versions [&uarr;](#PHP)

#### PHP 1 (Personal Home Page Tools)

PHP был разработан Расмусом Лердорфом в 1995 году. В то время этот термин все еще обозначал инструменты для персональной домашней 
страницы и первоначально задумывался как замена набора сценариев Perl, написанных Лердорфом для регистрации обращений к его онлайн-резюме.

#### PHP / FI (PHP 2)

Лердорф создал более обширную версию на языке программирования C, на котором PHP разрабатывается и по сей день. Наконец-то 
выпущенный PHP / FI (FI означает интерпретатор форм) был очень похож на Perl, хотя и более ограничен.

#### PHP 3

Энди Гутманс и Зеев Сураски в 1997 году переписали PHP 3. По их мнению, выпущенный к настоящему времени код PHP / F2 был 
неадекватным для электронной коммерции. Теперь Лердорф сотрудничал с Гутом и Сураски, и поэтому разработку PHP / FI он 
прекратил. По мнению разработчиков, версия PHP 3 значительно продвинула в распространении языка веб-скриптов PHP.

#### PHP 4

Компания Zend Technologies Ltd., основанная Гутмансом и Сураски, впоследствии разработала Zend Engine 1, который лежит 
в основе реализации стандарта PHP 4. PHP 4 улучшил скорость выполнения сложных приложений и безопасность при использовании 
глобальных переменных. Также были представлены поддержка многих других веб-серверов, управление сеансами и буферизация вывода, 
а также ряд новых языковых конструкций.

В конце 1990-х годов Всемирная паутина значительно расширилась, и возникла острая необходимость в языке сценариев для создания 
динамических веб-страниц. PHP стал более популярным для веб-разработки, чем предыдущий стандарт Perl. Его специализация делала 
его более простым в освоении. С 2008 года разработка и поддержка PHP 4 была прекращена.

#### PHP 5

Пятая версия PHP была выпущена разработчиками 13 июля 2004 года. Изменения включают обновление ядра Zend (Zend Engine 2), что существенно
увеличило эффективность интерпретатора. Введена поддержка языка разметки XML. Полностью переработаны функции ООП, которые стали во многом
схожи с моделью, используемой в Java. В частности, введён деструктор, открытые, закрытые и защищённые члены и методы, окончательные члены и
методы, интерфейсы и клонирование объектов. Нововведения, однако, были сделаны с расчётом сохранить наибольшую совместимость с кодом на
предыдущих версиях языка. На данный момент последней стабильной веткой является PHP 5.6, которая содержит ряд изменений и дополнений:

- Увеличена скорость работы, примерно на 10-20%
- Введено пространство имён
- Позднее статическое связывание и специальный метод __callStatic()
- Лямбда-функции и замыкания
- Добавление расширений: intl, phar, fileinfo и sqlite3
- Опциональный сборщик мусора
- Был написан драйвер MySQLnd для самой популярной у PHP разработчиков базы данных MySQL. С появлением нативного драйвера скорость работы с Mysql значительно увеличилась, также новый драйвер доступен уже в стандартной сборке(ранее это было невозможно из-за лицензии, связанной с libmysql)
- Прекращение поддержки версий операционной системы до Windows 2000 (Windows 98, NT4, и.т.д.)
- Новые синтаксические конструкции, такие как NOWDOC, ограниченный GOTO, короткий вид тернарного оператора «?:»


PHP 5.3:

- `?:` — сокращение тернарного оператора
- `$func = function() use (){ }` — анонимные (лямбда) функции
- `method()->var` — получение объекта из метода/функции
- `<<<'DOC'` — поддержка NOWDOC
- `namespace` — поддержка пространств имен
- `__DIR__` — новая магическая константа
- `$class::$foo` — динамичное указание класса
- `const` — ключевое слово для создания констант вне классов
- `static::method()` — статическое связывание
- `goto hell;` — оператор goto
- `__callStatic(), __invoke()` — магические методы

PHP 5.4:

- `<?=` — короткая запись вывода на экран работает всегда
- `[1,2]` — запись массива, без слова array
- `trait Class {}` — примеси (трейты)
- `foo()[0]` — быстрое получение элемента массива
- `(new Foo)->method()` — доступ к элементу объекта при его создании
- `Class::{'foo'}()` — динамичное указание метода
- `callable` — новый тип для аргументов функции/метода
- `@` — улучшена производительность


PHP 5.5:

- `[1,3,4][2], "foobar"[2]` — разыменования созданных массивов/строк
- `empty()` — можно применять к результатам функций и выражений
- `list()` в foreach
- `finally` — в конструкции try/catch
- `Class::class` — для получение имени класса в пространствах
- `yield` — создание генераторов
- `API для хэширования паролей`


PHP 5.6:

- `const PLUS = 1 + 2;` — скалярные выражения в константах/свойствах/аргументах функции
- `const ARR = ['a', 'b'];` — константа может хранить массив
- `func( ...$args ) или func( ...[2, 3] )` — запаковка/распаковка параметров функции
- `**` — оператор возведения в степень
- `use function и use const` — импорт функций и констант в пространство


#### PHP 6

Шестая версия PHP находилась в стадии разработки с октября 2006 года. В ней уже было сделано множество нововведений, как, например,
исключение из ядра регулярных выражений POSIX и «длинных» суперглобальных массивов, удаление директив safe_mode, magic_quotes_gpc и r
egister_globals из конфигурационного файла php.ini. 

Основные усилия были сосредоточены на поддержке Юникода. Однако в марте 2010 года разработка PHP6 была признана бесперспективной 
из-за сложностей с поддержкой Юникода. Исходный код PHP6 перемещён на ветвь, а основной линией разработки стала версия 5.4.

#### PHP 7

В 2014 году было проведено голосование, по результатам которого следующая версия получила название PHP 7.
Выход новой версии планировался в середине октября 2015 года. В марте 2015 года Zend представили инфографику, в которой описаны основные
нововведения PHP 7.

PHP 7 имеет на 30 процентов меньшее время выполнения, чем PHP 5, из-за новой реализации хеш-таблиц. Кроме того, благодаря 
различным изменениям в ядре PHP новая версия занимает меньше места на диске, чем PHP 5. Такие компоненты, как парсер, лексер и 
генератор байт-кода, также претерпели некоторые изменения. Версия 7.0 была выпущена 3 декабря 2015 года. В декабре 2016 года 
был выпущен PHP 7.1. В декабре 2017 вышла версия 7.2, а в ноябре 2019 — версия 7.4.

Новая версия основывается на экспериментальной ветви PHP, которая изначально называлась phpng (PHP Next Generation — следующее поколение),
и разрабатывалась с упором на увеличение производительности и уменьшение потребления памяти. В новой версии добавлена возможность указывать
тип возвращаемых из функции данных, добавлен контроль передаваемых типов для данных, а также новые операторы.


PHP 7:

- `$a ?? ''` — isset и получение значения
- `$a <=> $b` — три сравнения сразу: больше, равно, меньше
- `define( 'FOO', [1,2] );` — массив в define константе
- `use name\space\{A, B, C as c};` — группировка импорта
- `int, float, bool` — новые типы параметров функции/метода
- `int, float, bool, array` — типы возврата функции/метода
- `foo()(), $a::$b::$c, $$foo->bar` — единый синтаксис: СЛЕВА НАПРАВО
- `foreach` — изменена логика работы
- `$class = new class{}` — анонимные классы
- `yield ... return 99;` — возврат выражений в генераторах
- `yield from func()` — делегирование генераторов


PHP 7.1:

- `?string` — Обнуляемый тип (и null тип)
- `void` — возвращаемый тип
- `['key'=>$var] = ['key'=>'Значение']` — Деструктурирование массивов
- `list( 'id'=>$id ) = $data` — поддержка ключей в list()
- `Closure::fromCallable()` — новый статический метод Closure
- `private const` — Область видимости констант в классах
- `iterable` — новый псевдо-тип
- `?int = null` — тип передаваемых/возвращаемых значений
- `$string[-1]` — отрицательное значение смещения в строках
- `catch (First | Second $e)` — обработка нескольких исключений в одном блоке catch


PHP 7.2:

- `Закрывающая запятая для любых списков`


PHP 7.3:

- `Heredoc и Nowdoc` ― Улучшен синтаксис
- `list( &$a )` — cсылки в list()
- `is_countable()` — функция
- `array_(key|value)_(first|last)()` — новые функции


PHP 7.4:

- `[ ...$arr ]` — распаковка массива внутри массива
- `public int $id` — типизация для свойств класса
- `fn( $x ) => $x` — стрелочные функции
- `covariance & contravariance`
- `??=` — coalesce assign оператор
- `299_792` — знак _ в числах
- `WeakReference` — слабые ссылки
- `strip_tags( $str, ['a', 'p'] )`
- `__serialize() __unserialize()` — магические методы
- `array_merge()` — вызов без аргументов
- `Исключения из __toString()`


#### PHP 8

PHP 8 была выпущена в конце ноября 2020 года. Версия поддерживает современную компиляцию, которая повышает почти на 50 % 
производительность в микро-тестах. Например, PHP 8 предоставляет расширение WeakRefs, которая обеспечивает ресурсосберегающую 
обработку объектов. Помимо этого, поддерживаются произвольные типы объединения.


PHP8.0:

- `Union Types`. В PHP 8 разработчики могут указывать, что аргумент функции или возвращаемое значение может быть одним из нескольких возможных типов, а не только одним конкретным типом. Например, функция, ожидающая в качестве аргумента целое число или число float, теперь может быть определена как принимающая тип union "int|float".
- `JIT`. JIT, или Just-In-Time компиляция ― это технология, значительно повышающая скорость выполнения кода в языках программирования. Механизм JIT в PHP 8 компилирует машинный код непосредственно перед его исполнением. Движок JIT также способен определять части кода, которые выполняются чаще всего, и компилировать их в машинный код, повышая общую производительность приложения.
- `$country = $session?->user?->getAddress()?->country;` - `Nullsafe-оператор` - Вместо нулевых (null) условий проверки теперь вы можете использовать цепочку вызовов с новым nullsafe оператором. Когда оценка одного элемента в цепочке завершается неудачно, выполнение всей цепочки прерывается, и вся цепочка принимает значение null.
- `htmlspecialchars($string, double_encode: false);` - `Именованные аргументы` - Указывайте только обязательные параметры, пропуская необязательные. Аргументы не зависят от порядка и самодокументированы.
- `Атрибуты` - Атрибуты предоставляют возможность добавления метаданных с нативным синтаксисом PHP в классы удобным способом. Данная опция позволяет разделить абстрактную реализацию некоторой функции и ее кодовое использование. Атрибуты – это новые возможности и технически более совершенный способ добавлять дополнительную информацию и конфигурацию.
- `Слабые карты (weak maps)`. Слабые карты предоставляют возможность связывать объекты с метаданными, не мешая при этом сборщику мусора удалять объекты из памяти. Это полезно в сценариях, когда вам нужно связать некоторые данные с объектом, но при этом автоматически удалять объект, когда он больше не нужен. Данные также будут автоматически удалены вместе с объектом. Это поможет предотвратить утечки памяти и повысить производительность в долгоиграющих процессах. Например, слабая карта может быть использована для запоминания результата вычислений.
- `Поддержка выражений Match`. Выражение Match позволяет сопоставить заданное значение с набором возможных случаев и соответствующих им действий. Синтаксис похож на оператор switch, но с большей гибкостью в плане шаблонов, которые могут быть сопоставлены. Выражения Match могут применять различные типы шаблонов, такие как литералы, переменные и другие, а также иметь несколько условий и действий в одном операторе.
- `Продвижение свойств конструктора (Constructor property promotion)`. Теперь можно определять и инициализировать свойства объектов непосредственно в методе конструктора, сокращая объем необходимого кода и улучшая его читабельность.
- `Saner string to number comparisons` - При сравнении с числовой строкой PHP 8 использует сравнение чисел. Иначе число преобразуется в строку и используется сравнение строк.
- `str_contains, str_starts_with, str_ends_with` - Поиск по строкам
- `Allow ::class on objects` - Теперь можно использовать класс на объектах. То есть если в «семерке» создаем экземпляр класса и хотим получить его класс, нам нужно было вызвать метод get_class. Теперь же можно получить класс через статическое свойство class, получить к нему доступ и не вызывать дополнительные функции.
- `Static return type`
- `Weak Map` - Восьмая версия дополнена классом WeakMaps, позволяющим сохранять ссылку на объект. При этом сам объект можно свободно удалить.
- `Deprecate left-associative ternary operator` - Левоассоциативный тернарный оператор. Теперь такие вложенные «монстры» будут выдавать ошибку. Их давно уже пора было запретить, и наконец это сделали. Можно написать нормальные If-ы или использовать match.
- `Change the precedence of the concatenation operator` - Изменение приоритета оператора конкатенации. В восьмой версии поменялся приоритет оператора конкатенации. Если раньше сначала надо было конкатенировать, потом складывать, то сейчас конкатенация идет уже после сложения.
- `Allow trailing comma in parameter list` - 
- `Stringable`
- `Throw is an Expression` - В прежних версиях перехват исключения был возможен с предварительным сохранением его в переменной. При этом не имело значения, использовалась ли переменная. PHP 8 позволяет перехватывать исключения, указание переменной при том не требуется. При этом следует иметь ввиду, что тип нужно указывать обязательно: PHP 8 не предусматривает возможность оставлять пустой catch.
- `Stable sorting`
- `Non-capturing catches` - В PHP 8 можно ловить исключение в catch-блоке без переменной. Иными словами, можно просто написать, какой тип исключений мы ловим, и если эту переменную никак не используем, то просто здесь говорим, что у нас выводится строка сообщением и все. То есть если мы не хотим никак обрабатывать эти данные, чтобы не засорять память, мы просто не используем здесь переменные.
- `Ensure correct signatures of magic methods`
- `Always available JSON extension`
- `Stricter type checks for arithmetic/bitwise operators`
- `Validation for abstract trait methods` - Валидация абстрактных методов в трейтах. Теперь, если объявить трейт с абстрактным публичным методом «тест», который принимает интеджер в качестве параметра, и в классе применить этот трейт, но при этом написать переопределение метода со string, то теперь это выдаст ошибку.
- `Fields types and links`
- `Mixed Type v2`


PHP8.1:

- `Поддержка перечислений` - Используйте перечисления вместо набора констант, чтобы валидировать их автоматически во время выполнения кода.
- `Readonly-свойства` - Readonly-свойства нельзя изменить после инициализации (т.е. когда им было присвоено значение). Они будут крайне полезны при реализации объектов типа VO и DTO.
- `Callback-функции как объекты первого класса` - С помощью нового синтаксиса любая функция может выступать в качестве объекта первого класса. Тем самым она будет рассматриваться как обычное значение, которое можно, например, сохранить в переменную.
- `Расширенная инициализация объектов` - Объекты теперь можно использовать в качестве значений параметров по умолчанию, статических переменных и глобальных констант, а также в аргументах атрибутов.
- `Пересечение типов` - function count_and_iterate(Iterator&Countable $value) {} - Теперь в объявлении типов параметров можно указать, что значение должно относиться к нескольким типам одновременно. В данный момент пересечения типов нельзя использовать вместе с объединёнными типами, например, A&B|C.
- `Тип возвращаемого значения never` - function redirect(string $uri): never {} - Функция или метод, объявленные с типом never, указывают на то, что они не вернут значение и либо выбросят исключение, либо завершат выполнение скрипта с помощью вызова функции die(), exit(), trigger_error() или чем-то подобным.
- `Окончательные константы класса` - Теперь константы класса можно объявить как окончательные (final), чтобы их нельзя было переопределить в дочерних классах.
- `Файберы` - это примитивы для реализации облегчённой невытесняющей конкурентности. Они являются средством создания блоков кода, которые можно приостанавливать и возобновлять, как генераторы, но из любой точки стека. Файберы сами по себе не предоставляют возможностей асинхронного выполнения задач, всё равно должен быть цикл обработки событий. Однако они позволяют блокирующим и неблокирующим реализациям использовать один и тот же API.
- `Поддержка распаковки массивов со строковыми ключами` - PHP раньше поддерживал распаковку массивов с помощью оператора ..., но только если массивы были с целочисленными ключами. Теперь можно также распаковывать массивы со строковыми ключами.


PHP8.2:

- `Readonly-классы` - readonly class BlogData {}
- `Типы в виде дизъюнктивной нормальной формы (ДНФ)` - public function bar((A&B)|null $entity) { } - ДНФ позволяет совместить объединение и пересечение типов, при этом обязательно типы пересечения следует сгруппировать скобками.
- `Самостоятельные типы null, false и true`
- `Новый модуль "Random"` - Модуль "random" предлагает новый объектно-ориентированный API для генерации случайных чисел.
- `Константы в трейтах` - Нельзя получить доступ к константе через имя трейта, но можно через класс, который использует этот трейт.
- `Динамические свойства объявлены устаревшими` - Чтобы помочь избежать ошибок и опечаток, больше не рекомендуется определять динамические свойства, только если сам класс явно не разрешит это при помощи атрибута #[\AllowDynamicProperties]. В экземплярах stdClass по-прежнему можно использовать динамические свойства.


### Reflection API [&uarr;](#PHP)

Поговорим для начала о том, что же вообще такое рефлексия (от англ. reflection - отражение) в программировании.
Этот термин пришёл к нам из психологии. Там данное слово означает способность человека к самоанализу, оценке своих поступков, мыслей и прочего вот этого всего.
Кроме того, человек в процессе всего этого может ещё и изменять свою точку зрения, что приведёт к изменению его поведения.

    Рефлексия означает процесс, во время которого программа может отслеживать 
    и модифицировать собственную структуру и поведение во время выполнения.

В PHP имеется очень мощный набор инструментов, позволяющий реализовать рефлексию.
Рассмотрим некоторые инструменты для рефлексии, о которых мы уже знаем.
Языковые конструкции self и static, магические константы __DIR__ и __CLASS__, функции get_defined_vars(), func_get_args() или eval().

    В конце концов возможность создавать объект класса, имя которого хранится в переменной:
    $obj = new $className();
    
    а затем и вызов метода, название которого так же хранится в переменной:
    $obj->$methodName();

Всё это рефлексия, всё это используется для того, чтобы влиять на поведение программы непосредственно во время её выполнения.

PHP включает в себя полноценный Reflection API, который предоставляет возможность проводить интроспекцию классов, интерфейсов, функций, методов и модулей.
Кроме того, Reflection API позволяет получать doc-блоки комментариев функций, классов и методов.

PHP Reflection API – это набор специальных классов-рефлекторов, позволяющих вывести рефлексию на новый уровень.
С помощью этих классов мы можем создавать объекты-рефлекторы для разных типов данных в PHP, которые позволят творить с ними всё что только вздумается.

PHP даёт вам ключ к любому запертому ящику, таким образом мы имеем ключи
для следующего:

    ReflectionClass: сообщает информацию о классе.
    ReflectionFunction: сообщает информацию о функции.
    ReflectionParameter: извлекает информацию о параметрах функции или метода.
    ReflectionClassConstant: сообщает информацию о константе класса.

### Что такое PEAR и PECL? [&uarr;](#PHP)

    PEAR - (PHP Extension and Application Repository) — это библиотека классов PHP с открытым исходным кодом.
    PEAR - это по сути предшественник Composer. Добавляет внешние библиотечки PHP, но на уровне системы, а не одного проекта.

    PECL (англ. PHP Extension Community Library) — это репозиторий модулей для PHP, написанных на C, доступных через систему пакетов PEAR.
    PECL был создан, когда возникла проблема удаления некоторых модулей из стандартной поставки PHP.
    В PECL находится ряд модулей к PHP, которые по каким-либо причинам (морально устарели, не прошли тестирование,
    имеются более функциональные аналоги) не входят в стандартную поставку PHP.
    PECL - это компилируемые расширения языка. Можно поставить API для memcache через него, а можно и через пакет в Ubuntu/Debian.

    Лично я считаю, что лучше добавлять как пакет, если есть возможность, поскольку aptitude знает о зависимостях между пакетами и при обновлении проблем не должно быть. 
    А если через PECL поставили, то готовьтесь к ручной переустановке.

### Обработка ошибок [&uarr;](#PHP)

    try {
    ... защищённый участок кода ...
    } catch (Exception $e) {
    ... код, если возникла исключительная ситуация ...
    } finally {
    ... код с гарантированный выполнением ...
    }

Не все ошибки — исключения

    В PHP все ошибки имеют тип в виде предопределённых констант: E_ERROR, E_WARNING, E_NOTICE и т.д.
    Так вот ошибки E_WARNING не являются исключительной ситуацией, поскольку программа может продолжить своё выполнение дальше.
    Это важное понимание того, что такое исключения — отслеживание аварийных ситуаций, чтобы продолжить дальнейшее выполнение программы.
    То есть когда мы пытаемся поделить число на ноль, то это всего лишь некорректная обработка входящих данных, которая не может привести к полному краху.



### Типы данных в PHP [&uarr;](#PHP)

В PHP есть десять базовых типов данных:

- `bool` - (логический тип)
- `int` - (целые числа)
- `float` - (дробные числа)
- `string` - (строки)
- `array` - (массивы)
- `object` - (объекты)
- `callable` - (функции)
- `mixed` - (любой тип)
- `resource` - (ресурсы)
- `null` - (отсутствие значения)

Из этих типов данных первые четыре являются скалярными: bool, int, float, string.
Скалярный тип данных включает в себя числовые и строковые данные, а также ссылки.

### Псевдотипы [&uarr;](#PHP)

- `mixed` - mixed говорит о том, что параметр может принимать много (но необязательно все) типов.
- `number` - говорит о том, что параметр может быть либо integer, либо float.
- `callback` - Псевдотип callback использовался в этой документации до того, как был введен тип callable в PHP 5.4. Он означает в точности то же самое.
- `array|object` - указывает, что параметр может быть как массивом array, так и объектом object.
- `void` - означает, что возвращенное значение бесполезно. void в списке параметров означает, что функция не принимает параметров. Начиная с PHP 7.1, void разрешается использовать в качестве подсказки возвращаемого типа функции.


### Анонимные функции, замыкания [&uarr;](#PHP)

    Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определенных имен. 
    Они наиболее полезны в качестве значений callback-параметров, но также могут иметь и множество других применений.

    Анонимные функции реализуются с использованием класса Closure.
    Анонимные функции выдают объекты этого типа. Класс получил методы, позволяющие контролировать анонимную функцию после её создания.


    $message = 'привет';
    
    $example = function () use ($message) {
    var_dump($message);
    };
    $example();

Автоматическое связывание $this

    class Test
    {
        public function testing()
        {
            return function() {
                var_dump($this);
            };
        }
    }
    
    $object = new Test;
    $function = $object->testing();
    $function();


### Назовите 5 различных функций для работы с массивами. [&uarr;](#PHP)

- `array_chunk` - Разбивает массив на несколько меньших массивов заданного размера
- `array_combine` - Создает массив из двух заданных массивов - массива индексов элементов и массива значений
- `array_diff` - Формирует массив из тех элементов первого заданного массива, которые отсутствуют в остальных заданных в качестве аргументов функции массива
- `array_intersect` - Формирует массив из элементов, которые присутствуют во всех заданных массивах
- `array_key_exists` - Проверяет наличие заданного индекса в массиве
- `array_keys` - Возвращает массив из индексов заданного массива
- `array_merge` - Объединяет несколько массивов в один
- `array_pop` - Возвращает последний элемент массива, одновременно удаляя элемент из массива
- `array_push` - Добавляет заданные элементы в конец массива

### Функции сортировки массивов - несколько штук [&uarr;](#PHP)

- `arsort` - Сортирует массив по убыванию его значений, сохраняя индексы неизменными
- `asort` - Сортирует массив по возрастанию его значений, сохраняя индексы неизменными
- `krsort` - Сортирует массив по убыванию его индексов
- `ksort` - Сортирует массив по возрастанию его индексов
- `sort` - Сортирует массив по возрастанию значений его элементов с перенумерацией его индексов
- `usort` - Сортирует массив с использование заданной функции сравнения элементов массива
- `rsort` - Сортирует массив по убыванию значений его элементов с перенумерацией его индексов

### !empty() vs isset() [&uarr;](#PHP)

    isset() - определяет, установлена ли переменная. Если переменная существует и её значение не null, то функция вернёт true, иначе - false.
    
    empty() - проверяет переменную на существование и на пустоту. Если переменная существует, и в ней есть не пустое значение или true, 
    то функция вернёт false, иначе true.

### отличие include от require. [&uarr;](#PHP)

    Обе функции одинаковы, но они имеют одно различие. Разница в том, что функция include() выдает предупреждение, но скрипт продолжит выполнение,
    а функция require() выдает предупреждение и фатальную ошибку, т. е. скрипт не будет продолжать выполнение.

###ПРОЕКТИРОВАНИЕ

### Что такое MVC и какие преимущества его использования? [&uarr;](#PHP)

MVC — это шаблон программирования, который позволяет разделить логику приложения на три части:

    Model (модель). Получает данные от контроллера, выполняет необходимые операции и передаёт их в вид.
    View (вид или представление). Получает данные от модели и выводит их для пользователя.
    Controller (контроллер). Обрабатывает действия пользователя, проверяет полученные данные и передаёт их модели.

Впоследствии шаблон проектирования стал эволюционировать. Например, была представлена иерархическая версия HMVC; MVVM.

HMVC (англ. Hierarchical model–view–controller) — Иерархические Модель-Вид-Контроллер, одно из расширений архитектурного паттерна MVC,
позволяющее решить некоторые проблемы масштабируемости приложений, имеющих классическую MVC-архитектуру.
Согласно парадигме HMVC, каждая отдельная MVC триада используется в качестве слоя в иерархической структуре. При этом, каждая триада в этой
иерархии независима от других, и может обратиться к контроллеру другой триады. Такой подход существенно облегчает и ускоряет разработку сложных
приложений, облегчает их дальнейшую поддержку и масштабирование, способствует повторному использованию кода.

Model-View-ViewModel (MVVM) — шаблон проектирования архитектуры приложения. Представлен в 2005 году Джоном Госсманом (John Gossman)
как модификация шаблона Presentation Model.
Используется для разделения модели и её представления, что необходимо для их изменения отдельно друг от друга.
Например, разработчик задаёт логику работы с данными, а дизайнер работает с пользовательским интерфейсом.


### логика в контроллере, должна ли быть и почему [&uarr;](#PHP)

На самом деле контроллер связующее звено. Он должен быть тонким, но не более чем нужно.
Сами по себе контроллеры берут на себя, например, валидацию входных данных, построение http ответа и тд.
Все логика должна выносится в сервисы. Чтобы вы понимали, сервис - это просто класс, зачастую, без хранения состояния и с единственным методом,
который содержит бизнес логику. Из контроллера будет вызываться метод этого сервиса, тот будет возвращать результат.
Контроллер будет преобразовывать этот результат в нужный формат, дабы отдать его пользователь в нужном виде.
Сервисы можно не использовать в небольших приложениях.

И стоит рассказать в данном контексте о модели. Она может быть простой и смешиваться с энвироментом в виде эктив рекордс.
Или сложной. Иметь сверху обёртку в виде реализации сервисов, связывающих её с внешним миром, например, репозиториями,
внешними приходящими данными и т.д.
В контроллер стоит вынести приём данных из внешних источников, работу с правами, реакцию на события (логирование, отправка почты и т.д.).
Причём реакция - это не обязательно исполнение действий напрямую, но так же постановка их в очередь для обработчика.

И вот от сложности самой модели и её обёртки зависит тонкость контроллера.
Чем проще реализация модели, тем толще контроллер.

В небольших приложениях в контроллеры наваливают бизнес логику, чтобы не тратить время на построение архитектуры. Оно себя оправдывает.
Да мы лишаем себя возможности модульных тестов, но функциональные остаются рабочими. И это является противоречием назначению контроллера.
В проектах средней величины уже пытаются выносить бизнес логику в сервисы. Сервисный слой это и есть модель из множества классов.
В контроллере вызывается один-два из этих сервисов и данные передаются в представление. И все бы хорошо, связующее звено для сервисов..., но
это грамотно завуалированная бизнес логика, которую отчетливо видно лишь в крупных проектах.

В гораздо больших проектах количество различных сервисов возрастает в разы, контроллер превращается в один большой экшен, который сам является сервисом,
чтобы тратить меньше времени на поиск необходимого куска кода.


###СТРУКТУРЫ ДАННЫХ

### SPL классы [&uarr;](#PHP)

Стандартная библиотека PHP (SPL) — это набор интерфейсов и классов, предназначенных для решения стандартных задач.

SPL предоставляет ряд стандартных структур данных, итераторов для оббегания объектов, интерфейсов, стандартных исключений,
некоторое количество классов для работы с файлами и предоставляет ряд функций, например spl_autoload_register().

В библиотеке SPL содержатся такие структуры данных:

    Двусвязные списки
        SplDoublyLinkedList — Двусвязные списки
            SplStack — Стек
            SplQueue — Очередь

    Кучи
        SplHeap — Куча
            SplMaxHeap — Сортировка кучи по убыванию
            SplMinHeap — Сортировка кучи по возрастанию
        SplPriorityQueue — Приоритетные очереди

    Массивы
        SplFixedArray — Массив с ограниченной длиной

    Карта
        SplObjectStorage — Хранилище объектов


### Какие структуры данных вы знаете? [&uarr;](#PHP)

SplDoublyLinkedList - Двусвязный список ( DLL )

    SplDoublyLinkedList — двусвязный список. Каждый узел такого списка хранит ссылку на предыдущий и на следующий за ним узел. 
    Представьте, что вы находитесь в очереди и при этом можете видеть только человека перед вами и позади вас. 
    Это аналогия отношения связи между элементами в SplDoublyLinkedList. Вставка элемента в список соответствует ситуации, когда кто-то влез в очередь, а вы вдруг забыли, кто стоял перед вами (и этот кто-то забыл о вас).
    Двусвязный список позволяет эффективно обходить и добавлять большие наборы данных без необходимости повторного хеширования.

    Вообще, связный список — это базовая динамическая структура данных, состоящая из узлов, каждый из которых содержит как данные, так и ссылки 
    на следующий и/или предыдущий узел списка. Зачем они нужны? Их преимущество перед массивом — это структурная гибкость: порядок элементов 
    может не совпадать с порядком расположения данных в памяти, а обход всегда явно задаётся внутренними связями.
    Списки бывают трёх типов : одно-, дву- и XOR связные.

    Линейный однонаправленный список — это структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством 
    указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на NULL. Элемент, на который нет 
    указателя, является первым (головным) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке 
    можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.
    
    Двусвязный список — это список, ссылки в каждом узле которого указывают на предыдущий и на последующий узел. По двусвязному списку можно 
    эффективно передвигаться в любом направлении — как к началу, так и к концу. В этом списке проще производить удаление и перестановку элементов, 
    так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.

Мы же рассмотрим встроенную в SPL структуру данных — двусвязный список. В SPL он является основой для двух крайне важных и интересных структур.
Это стэк и очередь.

    Сам класс обеспечивает основные возможности двусвязного списка. Не секрет, что есть два принципа работы с элементами списка — FIFO и LIFO. 
    В DLL можно работать по любому из этих принципов. Это и позволяет реализовывать стэк и очередь.
    
    Все операции итератора, удаления, добавления и т.п. имеют алгоритмическую сложность O(1), что является очень дешёвой операцией.
    
    Вот операции, которые предоставляет SPL класс DLL
    count ( void ) — Подсчитывает количество элементов в двусвязном списке
    current ( void ) — Возвращает текущий элемент массива
    isEmpty ( void ) — Проверяет, является ли двусвязный список пустым
    key ( void ) — Возвращает индекс текущего узла
    next ( void ) — Перемещает итератор к следующему элементу
    prev ( void ) — Перемещает итератор к предыдущему элементу
    push ( mixed $value ) — Помещает элемент в конец двусвязного списка
    rewind ( void ) — Возвращает итератор в начало
    serialize ( void ) — Сериализует хранилище

SplQueue и SplStack

    SplQueue и SplStack очень похожи на SplDoublyLinkedList. Обе эти структуры, по сути, представляют собой двусвязные списки с разными флагами 
    итераторов(IT_MODE_LIFO — Last In First Out — последним пришёл, первым ушёл; и IT_MODE_FIFO — First In First Out — первым пришёл, первым ушёл), 
    которые регулируют порядок обработки узлов и что делать с этими элементами после того, как они будут обработаны. 
    Ещё одно отличие между этими структурами заключается в том, что интерфейс SplQueue содержит более интуитивно понятные методы enqueue() и dequeue()
    в отличие от методов push() и pop() у SplStack.

SplHeap

    SplHeap — куча, представленная в виде бинарного дерева, каждый узел которого имеет не более двух дочерних узлов. Это абстрактный класс, 
    требующий расширения с определением метода compare(), позволяющего выполнять сортировку в реальном времени при вставке новых узлов в дерево.

    От SplHeap наследуются два класса: SplMaxHeap – для сортировки массива по убыванию его значений, SplMinHeap – для сортировки массива по возрастанию.

SplMaxHeap и SplMinHeap

    SplMaxHeap и SplMinHeap — конкретные реализации абстрактного класса SplHeap. SplMaxHeapреализует метод compare() таким образом, чтобы дерево 
    было отсортировано в порядке убывания значений узлов, а SplMinHeap — в порядке возрастания значений.

SplPriorityQueue

    SplPriorityQueue — очередь, похожая на SplHeap, но в отличие от SplHeap сортировка осуществляется на основании значения свойства priority 
    (приоритет), заданного для каждого узла.

SplFixedArray

    SplFixedArray — массив фиксированной длины, индексами которого могут быть только целые числа. Эти ограничению обеспечивают более высокую 
    скорость обработки массива, которая достигается, в том числе, благодаря тому, что в SplFixedArray нет хеширования ключей элементов при их добавлении (в отличие от обычных массивов).

SplObjectStorage

    SplObjectStorage — хранилище объектов, предоставляет интерфейс для сопоставления объектов к данным, либо может быть использовано в качестве 
    контейнера для множества объектов. Позволяет использовать объект в качестве ключа ассоциативного массива и связать его с некоторыми данными.


### Разница стэка и очереди. [&uarr;](#PHP)

    Очередь, как и стек — это линейная структура данных, элементы в которой хранятся в последовательном порядке. 

    Наиболее часто встречающаяся аналогия для объяснения стека — стопка тарелок. 
    Вне зависимости от того, сколько тарелок в стопке, мы всегда можем снять верхнюю. 
    Чистые тарелки точно так же кладутся на верх стопки, и мы всегда будем первой брать ту тарелку, которая была положена последней.

    Очереди очень похожи на стеки. Они также не дают доступа к произвольному элементу, но, в отличие от стека, элементы кладутся (enqueue) и 
    забираются (dequeue) с разных концов. Такой метод называется «первый вошел, первый вышел» (First-In-First-Out или FIFO). 
    То есть забирать элементы из очереди мы будем в том же порядке, что и клали. Как реальная очередь или конвейер.

    Единственное существенное отличие между стеком и очередью заключается в том, 
    что в очереди вместо LIFO (Last In First Out — последним пришёл, первым ушёл) , действует принцип FIFO (First In First Out — первым пришёл, первым ушёл)

###DB

### Знакомы ли с ORM, ActiveRecord? [&uarr;](#PHP)

ORM (Object-Relation Mapping) – общее название для фреймворков, позволяющих автоматически связать базу данных с кодом. Они стараются скрыть существование базы данных настолько, насколько это возможно. Взамен, программисту дают возможность оперировать данными в базе через специальный интерфейс. Вместо построения SQL-запросов, программист вызывает простые методы, а всю остальную работу берёт на себя ORM.

    $user = new App\Models\User();
    $user->name = 'Petr';
    $user->save(); // сохранение пользователя в базу

Несмотря на общую цель, ORM бывают очень разными. Eloquent относится к наиболее распространённому и простому типу ORM, реализующему шаблон проектирования Active Record. Этот шаблон базируется на идее, что каждой таблице в приложении соответствует один класс (модель). Этот класс отвечает как за реализацию бизнес логики, так и за взаимодействие с базой данных. Последнее обычно появляется в модели за счёт наследования от базового класса ORM.

Кроме Active Record существует шаблон Data Mapper, он например, реализован в Doctrine. Этот подход разделяет сущности и код, связанный с базой данных, на два независимых слоя. Такой подход гибче, но при этом сложнее в работе.

Data Mapper — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже загружено и используется для логической обработки). Цель паттерна в том, чтобы держать представление данных в памяти и постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных. Слой состоит из одного или более mapper-а (или объектов доступа к данным), отвечающих за передачу данных. Реализации mapper-ов различаются по назначению. Общие mapper-ы могут обрабатывать всевозоможные типы сущностей доменов, а выделенные mapper-ы будет обрабатывать один или несколько конкретных типов.

Ключевым моментом паттерна Data Mapper, в отличие от Active Record является то, что модель данных следует Принципу Единой Обязанности SOLID.

Принцип единственной ответственности (англ. single-responsibility principle, SRP) — принцип ООП, обозначающий, что каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

Важная часть любой ORM — это Query Builder (построитель запросов). Это абстракция поверх SQL, которая упрощает генерацию запросов. Она обычно выглядит как цепочка функций, каждая из которых отвечает за конкретную часть SQL, например: ORDER, SELECT или WHERE.

    $users = App\Models\User::where('state', 'active')
    ->orderBy('name', 'desc')
    ->take(10)
    ->get();

Ещё одна обязанность ORM – изменение схемы базы данных: добавление, удаление и модификация таблиц. Делается это, как правило, не на чистом SQL, а с помощью специального языка. Это позволяет работать с ORM, не отвлекаясь на особенности конкретных баз данных. ORM сама создаёт правильный SQL-запрос, подходящий под конкретную базу данных:

    Capsule::schema()->create('users', function ($table) {
        $table->bigIncrements('id');
        $table->string('email')->unique();
        $table->string('first_name');
        $table->string('password');
        $table->string('last_name');
        $table->timestamps();
    });

В Eloquent используется подход Database First. Это значит, что для создания новых моделей или изменения поведения старых, нужно сначала изменить базу данных, а ORM сама подхватывает изменения и работает с ними. Например, для добавления нового свойства достаточно добавить новую колонку. В коде ничего менять не нужно, она автоматически начинает работать.

В некоторых ORM встречается подход Code First. В таком случае изменения делаются не в базе, а в коде. А дальше ORM сама формирует необходимые изменения для базы данных, подстраивая ее под код

PHP ORM:

Doctrine, ORM для PHP 7.1+ Бесплатное ПО (MIT), с открытым исходным кодом

    Doctrine — объектно-реляционный проектор (ORM) для PHP 7.1+, который базируется на слое абстракции доступа к БД (DBAL). Одной из ключевых возможностей Doctrine является запись запросов к БД на собственном объектно-ориентированном диалекте SQL, называемом DQL (Doctrine Query Language) и базирующемся на идеях HQL (Hibernate Query Language). 

    Doctrine ORM применяется во фреймворках Laravel, Yii, Symfony. 

    Doctrine версии 1.* следует паттерну Active Record для работы с данными[3]. Для примера, если программист хочет создать пользователя в базе данных, он может больше не использовать SQL, а написать следующий PHP код:

        $user = new User();
        $user->name = "john";
        $user->password = "doe";
        $user->save();
        echo "The user with id {$user->id} has been saved.";

    Doctrine версии 2.* следует паттерну Data mapper Для создания пользователя может использоваться следующий кодː

        $user = new User();
        $user->setName("john");
        $user->setPassword("doe");
        $entityManager->persist($user);
        $entityManager->flush();
        echo "The user with id {$user->getId()} has been saved.";


Eloquent, ActiveRecord ORM для PHP ^7.2, с открытым исходным кодом (MIT), из фреймворка Laravel. Она также доступна в качестве независимого компонента

    Eloquent - это реализация шаблона ActiveRecord в Laravel для работы с базами данных. Для каждой таблице в базе есть соответствующий класс-модель, который используется для работы с этой таблицей. Модель позволяет запрашивать данные из таблиц, вставлять новые записи и совершать другие действия.

### что такое PDO и подготовленные запросы [&uarr;](#PHP)

Большинство баз данных поддерживают концепцию подготовленных запросов. Что это такое? Это можно описать, как некий вид скомпилированного шаблона SQL запроса, который будет запускаться приложением и настраиваться с помощью входных параметров. У подготовленных запросов есть два главных преимущества:

    Запрос необходимо однажды подготовить и затем его можно запускать столько раз, сколько нужно, причём как с теми же, так и с отличающимися параметрами. Когда запрос подготовлен, СУБД анализирует его, компилирует и оптимизирует план его выполнения. В случае сложных запросов этот процесс может занимать ощутимое время и заметно замедлить работу приложения, если потребуется много раз выполнять запрос с разными параметрами. При использовании подготовленного запроса СУБД анализирует/компилирует/оптимизирует запрос любой сложности только один раз, а приложение запускает на выполнение уже подготовленный шаблон. Таким образом подготовленные запросы потребляют меньше ресурсов и работают быстрее. 

    Параметры подготовленного запроса не требуется экранировать кавычками; драйвер это делает автоматически. Если в приложении используются исключительно подготовленные запросы, разработчик может быть уверен, что никаких SQL-инъекций случиться не может (однако, если другие части текста запроса создаются с неэкранированным вводом, то SQL инъекция по-прежнему возможна). 

Подготовленные запросы также полезны тем, что PDO может эмулировать их, если драйвер базы данных не имеет подобной функциональности. Это значит, что приложение может пользоваться одной и той же методикой доступа к данным независимо от возможностей СУБД.

Если же в запрос передаётся хотя бы одна переменная, то этот запрос в обязательном порядке должен выполняться только через подготовленные выражения. Что это такое? Это обычный SQL запрос, в котором вместо переменной ставится специальный маркер - плейсхолдер. PDO поддерживает позиционные плейсхолдеры (?), для которых важен порядок передаваемых переменных, и именованные (:name), для которых порядок не важен. Примеры:

    $sql = 'SELECT name FROM users WHERE email = ?';
    $sql = 'SELECT name FROM users WHERE email = :email';

тобы выполнить такой запрос, сначала его надо подготовить с помощью функции prepare(). Она также возвращает PDO statement, но ещё без данных. Чтобы их получить, надо исполнить этот запрос, предварительно передав в него переменные. Передать можно двумя способами:
Чаще всего можно просто выполнить метод execute(), передав ему массив с переменными:

    $stmt = $pdo->prepare('SELECT name FROM users WHERE email = ?');
    $stmt->execute(array($email));

    $stmt = $pdo->prepare('SELECT name FROM users WHERE email = :email');
    $stmt->execute(array('email' => $email));

Как видно, в случае именованных плейсхолдеров в execute() должен передаваться массив, в котором ключи должны совпадать с именами плейсхолдеров.

ВАЖНО: Подготовленные выражения - основная причина использовать PDO, поскольку это единственный безопасный способ выполнения SQL запросов, в которых участвуют переменные.


###ООП

### 3 принципа ООП.  [&uarr;](#PHP)

Объектно-ориентированная парадигма

    Определение гласит, что «Объектно-ориентированное программирование – это парадигма программирования, в которой основной концепцией является понятие объекта, который отождествляется с предметной областью.»

    Таким образом, система представляется в виде набора объектов предметной области, которые взаимодействуют между собой некоторым образом. Каждый объект обладает тремя cоставляющими: идентичность (identity), состояние (state) и поведение (behaviour).

    Состояние объекта — это набор всех его полей и их значений.

    Поведение объекта — это набор всех методов класса объекта.

    Идентичность объекта — это то, что отличает один объект класса от другого объекта класса. С точки зрения Java, именно по идентичности определяется метод equals.

Принципы объектно-ориентированного программирования

    Инкапсуляция
    Наследование
    Полиморфизм

Инкапсуляция

    Научное определение гласит, что «Инкапсуляция – это принцип, согласно которому любой класс и в более широком смысле – любая часть системы должны рассматриваться как «черный ящик»: пользователь класса или подсистемы должен видеть только интерфейс (т.е. список декларируемых свойств и методов) и не вникать во внутреннюю реализацию.»

    Таким образом, получается, что если класс A обращается к полям класса B напрямую, это приводит не к тому, что «нарушается информационная безопасность», а к тому, что класс A завязывается на внутренне устройство класса B, и попытка изменить внутреннее устройство класса B приведет к изменению класса А. Более того, класс A не просто так работает с полями класса B, он работает по некоторой бизнес-логике. То есть логика по работе с состоянием класса В лежит в классе А, и когда мы захотим переиспользовать класс В, это не удастся сделать, ведь без кусочка класса А класс В может быть бесполезным, что приведет к тому, что класс В придется отдавать вместе с классом А. Экстраполируя это на всю систему, получается, что переиспользовать можно будет только всю систему целиком.

    Инкапсуляция является самым недооцененным принципом, который, к сожалению, мало кем интерпретируется правильно. Она позволяет минимизировать число связей между классами и подсистемами и, соответственно, упростить независимую реализацию и модификацию классов и подсистем.

Наследование

    Наследование — это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и
    методы.

    Наследование является самым переоцененным принципом. Когда-то считалось, что «У идеального программиста дерево наследования уходит в бесконечность и заканчивается абсолютно пустым объектом», потому как когда-то люди не очень хорошо понимали то, что наследование — это способ выразить такое свойство реального мира как иерархичность, а не способ переиспользовать код, отнаследовав машину от холодильника, потому что у обоих предметов есть ручка. Наследования желательно по возможности избегать, потому что наследование является очень сильной связью. Для уменьшения количества уровней наследования рекомендуется строить дерево «снизу-вверх».

Полиморфизм

    Полиморфизм — это возможность использовать классы – потомки в контексте, который был предназначен для класса – предка.

    За самым садистским определением кроется возможность языка программирования для декомпозиции задачи и рефакторинга if'ов и switch'ей.


### Особенности ООП в PHP.

Следует учитывать, что в PHP несколько упрощенная реализация ООП (объектно-ориентированное программирование). Поэтому, когда речь идёт об ООП как абстрактной парадигме, то следует использовать какой-то более серьёзный язык, вроде Java, С++ или Object Pascal. Потому что на этих языкам можно посмотреть практическую реализацию принципов ООП. В PHP программисты пытаются подражать другим ЯП, что в итоге приводит к излишней сложности и путанице, поскольку язык сам по себе не позволяет сделать «как в теории».

Нужно понимать, что PHP никогда не создавался как объектно-ориентированный. Это всегда был функциональный скриптовый язык, в задачу которого входило быстро выполнить небольшой код-вставку в HTML. ООП в PHP был добавлен по сути только в 5-й версии (2004 год), да и то в слишком простой форме. Более-менее говорить об ООП в PHP можно лишь с версии 5.3 (2009 год).

В PHP есть два ограничения. Первое — не может быть двух одноименных функций и второе — динамическая типизация, когда компилятор сам решает какой тип данных использовать (в PHP 7/8 идёт работа в сторону строгой типизации).

Поскольку в PHP функции не могут быть перегружены (то есть мы не можем создать две одноименные функции), а значит на этом уровне ad-hoc-полиморфизм просто отсутствует. Точно такая же ситуация и в методах классов — невозможно создать одноименную функцию.

Поэтому в PHP полиморфизм рассматривается как переопределение (или перекрытие), то есть когда потомок переопределяет метод родительского класса.

Часто приходится встречать выражение «Один интерфейс - много реализаций» (сказал Бьёрн Страуструп, автор C++). Выражение на само деле подходит лишь к «настоящему» полиморфизму, то есть не реализуемый в PHP. Часто приходится видеть совершенно бездумное раздувание кода, когда класс разбивается на абстрактный класс и интерфейс (потому что об этом сказал Страуструп...). То есть вместо одной сущности получается сразу несколько. При этом классы получают сложную логику наследования.

### Области видимости  [&uarr;](#PHP)

Область видимости свойства, метода или константы (начиная c PHP 7.1.0) может быть определена путём использования следующих ключевых слов в объявлении: public, protected или private.

Доступ к свойствам и методам класса, объявленным как public (общедоступный), разрешён отовсюду. Модификатор protected (защищённый) разрешает доступ самому классу, наследующим его классам и родительским классам. Модификатор private (закрытый) ограничивает область видимости так, что только класс, где объявлен сам элемент, имеет к нему доступ.

Свойства класса могут быть определены как public, private или protected. Свойства, объявленные без явного ключевого слова области видимости, определяются как общедоступные (public).

Методы класса могут быть определены как public, private или protected. Методы, объявленные без указания области видимости, определяются как public.

Начиная с PHP 7.1.0, константы класса могут быть определены как public, private или protected. Константы, объявленные без указания области видимости, определяются как public.

Объекты, которые имеют общий тип (наследуются от одного класса), имеют доступ к элементам с модификаторами private и protected друг друга, даже если не являются одним и тем же экземпляром. Это объясняется тем, что реализация видимости элементов известна внутри этих объектов.

Область видимости переменной

    Область видимости переменной - это контекст, в котором эта переменная определена. 

    Любая используемая внутри функции переменная по умолчанию ограничена локальной областью видимости функции.

Использование статических (static) переменных

    Другой важной особенностью области видимости переменной является статическая переменная. Статическая переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости. 

    Статические переменные также дают возможность работать с рекурсивными функциями. 

    Статическим переменным можно присвоить значения, являющиеся результатом выражения, но нельзя использовать для этого функцию, так это вызовет ошибку разбора. 

    Начиная с PHP 8.1.0, когда метод, использующий статические переменные, наследуется (но не переопределяется), унаследованный метод теперь будет использовать статические переменные совместно с родительским методом. Это означает, что статические переменные в методах теперь ведут себя так же, как статические свойства. 

    class Foo {
        public static function counter() {
            static $counter = 0;
            $counter++;
            return $counter;
        }
    }
    class Bar extends Foo {}
    var_dump(Foo::counter()); // int(1)
    var_dump(Foo::counter()); // int(2)
    var_dump(Bar::counter()); // int(3), до PHP 8.1.0 int(1)
    var_dump(Bar::counter()); // int(4), до PHP 8.1.0 int(2)

    PHP использует модификаторы переменных static и global как ссылки. Например, реальная глобальная переменная, внедрённая в область видимости функции указанием ключевого слова global, в действительности создаёт ссылку на глобальную переменную. Это может привести к неожиданному поведению


### Чем интерфейс отличается от абстрактного класса?  [&uarr;](#PHP)

Абстрактные классы в php реализуются добавлением ключевого слово abstract. Абстрактные классы могут иметь свойства и методы. Но в отличии от обычных классов, методы в абстрактных классах не имеют тела. Ключевое значение в таких методах — необходимость их реализации в дочерних классах.

Интерфейс — это тот же абстрактный класс, но у него нет свойств. Интерфейс объявляется при помощи ключевого слова interface.

Еще одной важной особенностью является то, что класс может унаследовать только один класс, но может реализовывать сколь угодно много интерфейсов.

Что такое Интерфейсы

    В общих чертах, Интерфейс должен описывать, как будет построен класс реализующий его, это похоже на план, описывающий публичные методы и константы, которые должны быть реализованы.

    Интерфейсы должны:

        Использоваться для определения публичных методов класса.
        Использоваться для определения констант класса.

    Интерфейсы не должны:

        Использоваться сами по себе.
        Использоваться для определения приватных или защищённых методов класса.
        Использоваться для определения свойств класса.

    Интерфейсы используются для определения публичных методов, которые должен включать класс. Важно помнить, что интерфейс всегда предназначен для реализации классом, поэтому в нём вы определяете только сигнатуру метода

    Почему же константы в интерфейсах не получили широкого распространения в промышленном коде, хотя и используются иногда? Причина в том, что их невозможно переопределить в интерфейсе-наследнике или в классе, реализующем данный интерфейс. Константы интерфейсов — самые константные константы в мире :)

Совместимость сигнатур методов

    Для дальнейшего изучения интерфейсов нам с вами нужно узнать о важнейшем понятии, которое незаслуженно обойдено вниманием в мануале по PHP: о понятии «совместимости сигнатур».

    Сигнатура — это описание функции (метода), включающее в себя:

        Модификатор доступа
        Имя функции (метода)
        Список аргументов, где для каждого аргумента указано:

            Тип
            Имя
            Значение по умолчанию
            либо оператор «три точки»

        Тип возвращаемого значения


    Примеры:

    function ();
    public function foo($arg = null);
    protected function sum(int $x, int $y, ...$args): int;

Наследование интерфейсов

    Интерфейсы могут наследоваться друг от друга:

    interface First
    {
        public const PI = 3.14159;
        public function foo(int $x);
    }

    interface Second
        extends First
    {
        public const E = 2.71828;
        public function bar(string $s);
    }

    Интерфейс-наследник получает от интерфейса-предка в наследство все определенные в предке методы и константы.

    В интерфейсе-наследнике можно переопределить метод из родительского интерфейса. Но только при условии, что либо его сигнатура будет в точности совпадать с сигнатурой родительского, либо будет совместима (см. предыдущий раздел)

    interface First
    {
        public function foo(int $x);
    }

    interface Second
        extends First
    {

    // Так можно, но бессмысленно
    public function foo(int $x);  

    // Так нельзя, фатальная ошибка Declaration must be compatible
    public function foo(int $x, int $y); 

    // Так можно, потому что эта сигнатура совместима с родительской - мы просто добавили необязательный аргумент
    public function foo(int $x, int $y = 0);  
    
    // Так тоже можно, все аргументы после "..." являются необязательными
    public function foo(int $x, ...$args);  

    // И так тоже можно
    public function foo(int $x, ...$args): int;  

    }

Что такое Абстрактные классы

    Абстрактные классы PHP очень похожи на интерфейсы PHP; они не предназначены быть классами сами по себе и представляют базовые методы без реализации.

    Абстрактный класс может:

        Использоваться для определения сигнатур методов класса с использованием abstract методов (аналогично интерфейсам).
        Использоваться для определения методов.
        Использоваться для определения констант класса.
        Использоваться для определения свойств класса.
        Расширятся дочерним классом.

    Абстрактный класс не может:

        Использоваться самостоятельно

Как решить, что использовать

    Это зависит от вашей цели. Сохранив аналогию с домом, если вы создаёте чертежи, которые в дальнейшем можно использовать для проектирования домов разных типов, вам нужен интерфейс.

    Если вы построили дом и вам нужно создать копии с улучшениями, то вам нужен абстрактный класс.

    Различие в применении абстрактного класса и интерфейса — очень тонкий вопрос. Абстрактный класс скорее служит для объединения семейства классов. Например, есть абстрактный класс Автомобиль, и от него наследуются классы Ford, Toyota, у которых есть общие методы (объявленные в абстрактном классе).
    Но если появляется класс Велосипед, то в нем нет смысла реализовывать, например, метод ПоменятьМасло. Для таких классов лучше описывать интерфейсы.

### Несколько конструкторов в классе  [&uarr;](#PHP)

Переопределением называют случаи, когда сигнатура метода (имя и параметры) в суперклассе и дочернем классе совпадают.

Когда два или более метода в одном классе имеют одинаковое имя, но разные параметры, это называется перегрузкой.

Перегрузка в PHP означает возможность динамически "создавать" свойства и методы. Эти динамические сущности обрабатываются с помощью магических методов, которые можно создать в классе для различных видов действий.

Методы перегрузки вызываются при взаимодействии со свойствами или методами, которые не были объявлены или не видны в текущей области видимости.

Интерпретация "перегрузки" в PHP отличается от большинства объектно-ориентированных языков. Традиционно перегрузка означает возможность иметь несколько одноимённых методов с разным количеством и типами аргументов.

Перегрузка свойств ¶

    Метод __set() будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.

    Метод __get() будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.

    Метод __isset() будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах.

    Метод __unset() будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве. 

    Замечание: 

    Возвращаемое значение __set() будет проигнорировано из-за способа обработки в PHP оператора присваивания. Аналогично, __get() никогда не вызывается при объединении присваиваний, например, подобным образом:

        $a = $obj->b = 8;

    Замечание:

    PHP не будет вызывать перегруженный метод изнутри того же перегруженного метода. Это означает, что, например, написание return $this->foo внутри __get() вернёт null и вызовет ошибку уровня E_WARNING, если не определено свойство foo, вместо того, чтобы вызвать метод __get() во второй раз. Однако методы перегрузки могут неявно вызывать другие методы перегрузки (например, метод __set() вызывает метод __get()). 

Перегрузка методов

     __call() запускается при вызове недоступных методов в контексте объект.

    __callStatic() запускается при вызове недоступных методов в статическом контексте. 

Конструкторы

    PHP позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-конструктор, будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, например, для инициализации какого-либо состояния объекта перед его использованием. 

    Начиная с PHP 8.0.0, параметры конструктора можно использовать для задания соответствующих свойств объекта. Это довольно распространённая практика — присваивать свойствам объекта параметры, переданные в конструктор, не производя никаких дополнительных преобразований. Определение свойств класса в конструкторе позволяет значительно сократить количество шаблонного кода для такого случая. 

    class Point {
        public function __construct(protected int $x, protected int $y = 0) {
        }
    }

`К сожалению, конструкторы, как и остальные методы класса в PHP, не могут быть «перегружены».`

Статические методы создания объекта

    PHP поддерживает только один конструктор для класса. Однако в некоторых случаях есть необходимость создавать объект разными путями в зависимости от разных входных данных. Рекомендуемый способ - использовать статические методы как обёртки над конструктором. 

    Конструктор можно сделать скрытым или защищённым для предотвращения его прямого вызова. В таком случае объект класса можно будет создать только с помощью статических методов. Так как это методы того же класса, они имеют доступ ко всем его скрытым методам, даже если они относятся к разным экземплярам класса. Скрытый конструктор опционален и может присутствовать или отсутствовать по необходимости. 

    
    class Product {

        private ?int $id;
        private ?string $name;

        private function __construct(?int $id = null, ?string $name = null) {
            $this->id = $id;
            $this->name = $name;
        }

        public static function fromBasicData(int $id, string $name): static {
            $new = new static($id, $name);
            return $new;
        }
    }

    $p1 = Product::fromBasicData(5, 'Widget');

    fromBasicData() принимает явные параметры, создаёт экземпляр класса через конструктор и возвращает объект.


### Трейты - зачем  [&uarr;](#PHP)

PHP реализует метод для повторного использования кода под названием трейт (trait).

    Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного наследования, таких как PHP. Трейт предназначен для уменьшения некоторых ограничений одиночного наследования, позволяя разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и реализованных с использованием разных архитектур построения классов. Семантика комбинации трейтов и классов определена таким образом, чтобы снизить уровень сложности, а также избежать типичных проблем, связанных с множественным наследованием и смешиванием (mixins).

    Трейт очень похож на класс, но предназначен для группирования функционала хорошо структурированным и последовательным образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию и позволяет сделать горизонтальную композицию поведения, то есть применение членов класса без необходимости наследования. 

    trait ezcReflectionReturnInfo {
        function getReturnType() { /*1*/ }
        function getReturnDescription() { /*2*/ }
    }

    class ezcReflectionMethod extends ReflectionMethod {
        use ezcReflectionReturnInfo;
        /* ... */
    }

    class ezcReflectionFunction extends ReflectionFunction {
        use ezcReflectionReturnInfo;
        /* ... */
    }

Приоритет

    Наследуемый член из базового класса переопределяется членом, находящимся в трейте. Порядок приоритета следующий: члены из текущего класса переопределяют методы в трейте, которые в свою очередь переопределяют унаследованные методы. 

Несколько трейтов ¶

    В класс можно добавить несколько трейтов, перечислив их в директиве use через запятую. 

Разрешение конфликтов

     Если два трейта добавляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешён.

    Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.

    Так как предыдущий оператор позволяет только исключать методы, оператор as может быть использован для включения одного из конфликтующих методов под другим именем. Обратите внимание, что оператор as не переименовывает метод и не влияет на какой-либо другой метод. 

Изменение видимости метода

    Используя синтаксис оператора as, можно также изменить видимость метода в использующем трейт классе. 

    trait HelloWorld {
        public function sayHello() {
            echo 'Hello World!';
        }
    }

    // Изменение видимости метода sayHello
    class MyClass1 {
        use HelloWorld { sayHello as protected; }
    }

    // Создание псевдонима метода с изменённой видимостью
    // видимость sayHello не изменилась
    class MyClass2 {
        use HelloWorld { sayHello as private myPrivateHello; }
    }

Трейты, состоящие из трейтов

    Трейты могут использоваться как в классах, так и в других трейтах. Используя один или более трейтов в определении другого трейта, он может частично или полностью состоять из членов, определённых в этих трейтах. 

Абстрактные члены трейтов

     Трейты поддерживают использование абстрактных методов для того, чтобы установить требования к использующему классу. Поддерживаются общедоступные, защищённые и закрытые методы. До PHP 8.0.0 поддерживались только общедоступные и защищённые абстрактные методы.
    
    Предостережение:

    Конкретный класс исполняет эти требования путём определения конкретного метода с тем же именем; при этом сигнатура метода может отличаться.

    trait Hello {
        public function sayHelloWorld() {
            echo 'Hello'.$this->getWorld();
        }
        abstract public function getWorld();
    }

    class MyHelloWorld {
        private $world;
        use Hello;
        public function getWorld() {
            return $this->world;
        }
        public function setWorld($val) {
            $this->world = $val;
        }
    }

Свойства

    Трейты могут также определять свойства. 

    trait PropertiesTrait {
        public $x = 1;
    }

    class PropertiesExample {
        use PropertiesTrait;
    }

    $example = new PropertiesExample;
    $example->x;

Статические члены трейта ¶

    В трейтах можно определять статические переменные, статические методы и статические свойства.

    Замечание:

    Начиная с PHP 8.1.0, вызов статического метода или доступ к статическому свойству непосредственно в трейте устарел. К статическим методам и свойствам следует обращаться только в классе, использующем трейт. 

Константы

    Начиная с версии PHP 8.2.0, трейты могут также определять константы. 

    Если трейт определяет константу, то класс не может определить константу с таким же именем, если только они не совместимы (одинаковая область видимости, начальное значение и модификатор final), иначе выбрасывается фатальная ошибка. 

    trait ConstantsTrait {
        public const FLAG_MUTABLE = 1;
        final public const FLAG_IMMUTABLE = 5;
    }

    class ConstantsExample {
        use ConstantsTrait;
    }

    $example = new ConstantsExample;
    echo $example::FLAG_MUTABLE; // 1



### Можно ли сделать множестенное наследование в PHP  [&uarr;](#PHP)

Стоит отметить, что в PHP мы можем унаследовать класс только от одного класса. Множественное наследование не поддерживается.

Если вам это понадобилось в PHP, значит пора внедрять интерфейсы. Свойства вы так не унаследуете, но опять таки если вам это понадобилось, пора от них избавляться в пользу методов.

Как альтернативу множественному наследованию - можно использовать трейты.

    Если ли в PHP множественное наследование?

    Если вам зададут такой вопрос, смело отвечайте: «да». Интерфейс может наследоваться от нескольких других интерфейсов.

    interface First
    {
        public function foo(int $x);
    }

    interface Second
    {
        public function bar(string $s);
    }

    interface Third
    extends First, Second
    {
        public function baz(array $a);
    }

    Правила решения конфликтов сигнатур методов при множественном наследовании:

    — либо сигнатуры совпадают полностью
    — либо сигнатура метода интерфейса, упомянутого в списке предков первым, должна быть совместима с сигнатурой из второго предка (да, порядок упоминания имеет значение, но это очень редкий кейс, просто не принимайте его никогда во внимание)

### Статические свойства и методы  [&uarr;](#PHP)

Ключевое слово static имеет в PHP три различных значения.

Значение первое — статическая локальная переменная

    В PHP переменные локальны. Это значит, что переменная, определенная и получившая значение внутри функции (метода), существует только во время выполнения этой функции (метода). При выходе из метода локальная переменная уничтожается, а при повторном входе — создается заново.

    function foo() {
        $a = 0;
        echo $a;
        $a = $a + 1;
    }

    foo(); // 0
    foo(); // 0
    foo(); // 0

    Однако всё меняется, если мы перед присваиванием поставим ключевое слово static:

    function foo() {
        static $a = 0;
        echo $a;
        $a = $a + 1;
    }

    foo(); // 0
    foo(); // 1
    foo(); // 2

    Ключевое слово static, написанное перед присваиванием значения локальной переменной, приводит к следующим эффектам:

    1) Присваивание выполняется только один раз, при первом вызове функции
    2) Значение помеченной таким образом переменной сохраняется после окончания работы функции
    3) При последующих вызовах функции вместо присваивания переменная получает сохраненное ранее значение

    Такое использование слова static называется статическая локальная переменная.

    Подводные камни статических переменных:

    1) Камень первый — статической переменной присваивать можно только константы или константные выражения.

    2) Камень второй — методы существуют в единственном экземпляре. Тут всё чуть сложнее. Для понимания сути приведу код:

    class A {
        public function foo() {
            static $x = 0;
            echo ++$x;
        }
    }

    $a1 = new A;
    $a2 = new A;

    $a1->foo(); // 1
    $a2->foo(); // 2
    $a1->foo(); // 3
    $a2->foo(); // 4

    Вопреки интуитивному ожиданию «разные объекты — разные методы» мы наглядно видим на этом примере, что динамические методы в PHP «не размножаются». Даже если у нас будет сто объектов этого класса, метод будет существовать лишь в одном экземпляре, просто при каждом вызове в него будет пробрасываться разный $this. 

Значение второе — статические свойства и методы классов

    В объектной модели PHP существует возможность задавать свойства и методы не только для объектов — экземпляров класса, но и для класса в целом. Для этого тоже служит ключевое слово static:

    Для доступа к таким свойствам и методам используются конструкции с двойным двоеточием («Paamayim Nekudotayim»), такие как ИМЯ_КЛАССА::$имяПеременной и ИМЯ_КЛАССА:: имяМетода().

    Оператор разрешения области видимости (также называемый "Paamayim Nekudotayim") или просто "двойное двоеточие" - это лексема, позволяющая обращаться к статическим свойствам, константам и переопределённым свойствам или методам класса. 

    Само собой разумеется, что у статических свойств и статических методов есть свои особенности и свои «подводные камни», которые нужно знать:

    1) Особенность первая, банальная — нет $this. Собственно это проистекает из самого определения статического метода — поскольку он связан с классом, а не объектом, в нём недоступна псевдопеременная $this, указывающая в динамических методах на текущий объект. Что совершенно логично.

    2) Особенность вторая — static не аксиома!

    class A {
        static public function foo() {
            echo 42;
        }
    }

    $a = new A;
    $a->foo();

    Вот так, да. Статический метод, если он не содержит в коде $this, вполне можно вызывать в динамическом контексте, как метод объекта. Это не является ошибкой в PHP.

    И кстати, всё написанное выше относится только к методам. Использование статического свойства через "->" невозможно и ведет к фатальной ошибке.

Значение третье, кажущееся самым сложным — позднее статическое связывание или LSB (Late Static Binding)

    Понять суть LSB проще всего на несложных примерах:

    class Model {
        public static $table = 'table';

        public static function getTable() {
            return self::$table;
        }
    }

    class User extends Model {
        public static $table = 'users';
    }

    echo User::getTable(); // 'table'

    Ключевое слово self в PHP всегда значит «имя класса, где это слово написано». В данном случае self заменяется на класс Model, а self::$table — на Model::$table.

    Такая языковая возможность называется «ранним статическим связыванием». Почему ранним? Потому что связывание self и конкретного имени класса происходит не в рантайме, а на более ранних этапах — парсинга и компиляции кода. Ну а «статическое» — потому что речь идет о статических свойствах и методах.

    Теперь вы понимаете, почему PHP ведёт себя в этой ситуации неинтуитивно. self был связан с классом Model тогда, когда о классе User еще ничего не было известно, поэтому и указывает на Model.

    Как быть?

    Для решения этой дилеммы был придуман механизм связывания «позднего», на этапе рантайма. Работает он очень просто — достаточно вместо слова «self» написать «static» и связь будет установлена с тем классом, который вызывает данный код, а не с тем, где он написан:

    class Model {
        public static $table = 'table';
        
        public static function getTable() {
            return static::$table;
        }
    }

    class User extends Model {
        public static $table = 'users';
    }

    echo User::getTable(); // 'users'

    Это и есть загадочное «позднее статическое связывание».

    Нужно отметить, что для большего удобства в PHP кроме слова «static» есть еще специальная функция get_called_class(), которая сообщит вам — в контексте какого класса в данный момент работает ваш код.


### Асинхронность, конкурентность, параллельность, многопоточность в PHP [&uarr;](#PHP)

Если кратко, то асинхронное выполнение кода - это возможность некий блок кода (иначе говоря, "задачу") выполнить не в заранее
заданном порядке, а в порядке, который зависит от.

От чего? От внешних условий: от наступления определенного события или, к примеру, наступления момента времени.

Самый простой пример, который можно привести, это, конечно, знаменитая функция setTimeout из JS

    setTimeout(function () { alert('Я выполнюсь через 5 секунд'); }, 5000);
    alert('А я выполнюсь сразу');

### Event loop - цикл событий [&uarr;](#PHP)

Всё дело в том, что PHP изначально не реализует так называемый "цикл обработки событий", или "Event Loop". Не реализует не потому,
что PHP - плохой язык, а JS - хороший, тут вообще не применимы моральные оценки - а потому что PHP зачастую живет в другой парадигме.

Как работает PHP, если опустить нюансы? Очень просто, "запрос" - "веб-сервер" - "процесс PHP" - "веб-сервер" - "ответ". И даже если
опустить дурацкую поговорку про то, что "PHP рожден, чтобы умирать", всё равно понятно, что в режиме совместной работы с веб-сервером
программа на PHP заинтересована в том, чтобы заканчивать свою работу как можно быстрее. Какие уж тут циклы событий, какая
асинхронность - чем быстрее процесс отработает, тем быстрее клиент получит ответ!

Но всё меняется, когда мы переходим от модели "веб-сервер + PHP" к написанию долгоиграющих консольных или, чем не шутит черт, GUI
(а такие примеры уже есть) приложений на PHP. В этих случаях необходимость отложенного выполнения кода становится очевидной, ведь
даже простейшая задача вроде "Если клиент нажал А, то..." становится асинхронной!

### Event-driven в Symfony - это асинхронность? [&uarr;](#PHP)

Коротко: нет.

Если рассмотреть встроенный, скажем в Symfony или Laravel или (это классический пример!) punBB механизм "событий", "уведомлений"
и их "обработчиков" - может сложиться ложное впечатление, что всё это - асинхронное выполнение кода.

На самом деле я глубоко убежден, что event-driven программирование на PHP в парадигме конечного процесса "запрос-работа-ответ" - это
средство прежде всего запутать программиста, создав у него иллюзию, что он овладел волшебной асинхронностью. При том, что на самом
деле он овладел искусством создания запутанной лапши вместо кода.

Поэтому - нет. Event-driven это не про асинхронность, это архитектурный паттерн построения синхронных программ, со сложным и
заранее непрогнозируемым потоком исполнения. Никакого цикла генерации и обработки событий этот паттерн не добавляет.

Разумеется, всё сказанное выше не имеет отношения к распределенной асинхронности, о которой речь пойдет дальше.

Событи́йно-ориенти́рованное программи́рование (англ. event-driven programming; в дальнейшем СОП) — парадигма программирования, в
которой выполнение программы определяется событиями — действиями пользователя (клавиатура, мышь, сенсорный экран), сообщениями
других программ и потоков, событиями операционной системы (например, поступлением сетевого пакета).

СОП можно также определить как способ построения компьютерной программы, при котором в коде (как правило, в головной функции программы)
явным образом выделяется главный цикл приложения, тело которого состоит из двух частей: выборки события и обработки события.

Как правило, в реальных задачах оказывается недопустимым длительное выполнение обработчика события, поскольку при этом программа не
может реагировать на другие события. В связи с этим при написании событийно-ориентированных программ часто применяют автоматное
программирование.

Автома́тное программи́рование — это парадигма программирования, при использовании которой программа или её фрагмент осмысливается как
модель какого-либо формального автомата. Известна также и другая «парадигма автоматного программирования, состоящая в
представлении сущностей со сложным поведением в виде автоматизированных объектов управления, каждый из которых представляет собой
объект управления и автомат». При этом о программе, как в автоматическом управлении, предлагается думать, как о системе
автоматизированных объектов управления.

Где применим данный подход

    Исходя из рассмотренного нами примера, можно сделать вывод, что такая архитектура хорошо показывает себя в больших системах, 
    где есть тяжелая бизнесс логика, которая может быть декомпозирована на последовательные или параллельные шаги выполнения. 
    Там, где нам не требуется синхронного взаимодействия с клиентами. То есть в большинстве систем :)
    
    Данный подход не требует полного переписывания проекта с нуля, он может внедряться в уже существующих системах, построенных на 
    (микро)сервисной архитектуре или в монолитах. 

Поговорим про инструменты

В рамках данной статьи будет очень сложно глубоко рассмотреть различные инструменты и провести их сравнительный анализ.
Однако, я попробую рассмотреть в общих чертах инструменты и технологии, которые мы можем использовать для построения
событийно-ориентированной архитектуры в рамках PHP-стека.

Каналы событий

Так как нам нужно передавать данные между компонентами/сервисами, будем использовать подходящие для этого инструменты:

    RabbitMQ — популярный брокер очередей, который позволяет строить сложный роутинг сообщений в очередях.

    Kafka — event-streaming платформа, которая позволяет пропускать через себя огромное количество событий, сохранять их и переиспользовать в будущем, а также при необходимости заново обрабатывать, начиная с какого-то определенного события в прошлом.

    Redis — in-memory key-value СУБД, которая из коробки поддерживает кучу структур данных и операций с ними, на основе которых можно строить собственные реализации очередей. А если не хватает функциональности из коробки — её можно расширить самописными Lua-скриптами.

    SQS — если вы пользуетесь облачной инфраструктурой, можно попробовать SQS или его аналоги. Простой инструмент, которым можно пользоваться из коробки, не нужно заморачиваться с установкой и настройкой — берёте и используете. Облачный провайдер берёт заботы по администрированию на себя.

Обработчики событий

А теперь самое интересное: как же нам обрабатывать информацию из очередей? Самым очевидным решением являются демоны — программы/скрипты,
которые работают в фоне в системе, они постоянно считывают информацию из очереди, и при получении сообщения оттуда — обрабатывают его.

Все мы знаем, что PHP был создан для того, чтобы постоянно умирать :)

Каждый раз, когда к нам приходит запрос от клиента, мы поднимаем PHP-скрипт, в рамках его выполнения отрабатывает бизнес-логика,
после чего скрипт завершает свою работу.

Нам нужно правильным образом научиться управлять нашими демонами: запускать и останавливать в безопасной точке, чтобы не прерывать
исполнение нашей бизнес-логики где-то на середине задачи. Если наш скрипт по какой то причине умрёт, он должен автоматически
перезапускаться.

### Распределенная асинхронность [&uarr;](#PHP)

Впрочем, всё меняется, если вы раскладываете свой код на >=2 независимых сервиса и соединяете их некой "шиной" или "очередью" событий.

В качестве такой "шины событий" может выступать, к примеру, RabbitMQ или, скажем, встроенный в Redis механизм PUB/SUB.

В таком случае мы действительно получаем настоящую асинхронность (ключевые для понимания моменты выделены):

    HTTP-сервис принимает запрос;

    Поняв, что бизнес-логика требует отложенного действия (например: отправки письма пользователю) HTTP-сервис создает в очереди событие, а сам продолжает выполняться дальше;

    Вспомогательный сервис, работая в cli и выполняя бесконечный цикл, получает из очереди уведомление о событии и выполняет связанную с ним задачу, а затем продолжает ждать следующее событие.

Это - асинхронное выполнение кода. Пусть и ценой увеличения количества сервисов в приложении.

Посмотрите, к примеру, как такой подход реализован в том же Laravel, где он называется "Queued Events".

### Кооперативная многозадачность на примере генераторов и корутин [&uarr;](#PHP)

Хорошо, предположим, что мы с вами в совершенстве освоили технику создания Event Loop и научились выполнять задачи отложенно. Но как быть, если задачи достаточно объемные? К примеру, задачей может быть чтение большого файла с данными, обработка этих данных и запись в базу. Поможет ли асинхронное исполнение оптимизировать производительность? Нет.

Нам нужно найти какой-то способ разбивать крупные задачи на кванты и выполнять их "дискретно", чередуя выполнение квантов задач. К примеру - прочитали одну строку из файла (квант задачи №1), преобразовали эти данные в нужный вид (квант задачи №2), записали в базу (квант задачи №3), снова вернулись к чтению очередной строки из файла (следующий квант задачи №2).

Если мы решим задачу квантования задач - мы получим в итоге так называемую "кооперативную многозадачность" или, иными словами, конкурентность. Кванты будут выполняться последовательно, конкурируя за процессорное время, но при этом возникнет иллюзия параллельного выполнения задач и неиллюзорная экономия ресурсов - ведь хранить в памяти и обрабатывать одну строчку из файла гораздо выгоднее, нежели прочесть весь файл целиком, а затем заняться им.

Для такого "квантования" в PHP существует ряд языковых средств. Первое из них - генераторы и корутины.

### yield [&uarr;](#PHP)

Генератор в целом выглядит как обычная функция, за исключением того, что вместо возвращения одного значения, генератор будет
перебирать столько значений, сколько необходимо. Любая функция, содержащая yield, является функцией генератора.

Когда вызывается генератор, он возвращает объект, который можно итерировать. Когда вы итерируете этот объект
(например, в цикле foreach), PHP вызывает методы итерации объекта каждый раз, когда вам нужно новое значение, после чего
сохраняет состояние генератора и при следующем вызове возвращает следующее значение.

Когда все значения в генераторе закончились, генератор просто завершит работу, ничего не вернув. После этого основной код
продолжит работу, как если бы в массиве закончились элементы для перебора.

В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо прекращения
работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при следующем вызове функции она
возобновит выполнения с места, на котором прервалась.

Польза yield не в экономии памяти, а в более красивом коде, который и память экономит, и позволяет инкапсулировать детали реализации.

foreach c генератором - это всего лишь красивая обёртка для цикла

    for ($i = 1; $i < 800000; $i++) {
        echo $i;
    }

Всю работу делает этот цикл. Генератор просто позволяет "вывернуть его наизнанку", и обращаться к получаемым в цикле значениям
не внутри, а "снаружи".

Отсюда и практическое применение генератора: оно не в "экономии памяти", а в использовании foreach. Везде, где foreach удобнее
while или for, генератор будет предпочтительнее. Он позволяет писать более красивый, и - главное - более универсальный код.
К примеру мы пишем обработчик каких-то данных, причем источник этих данных может быть совершенно разным - это может быть массив,
или текстовый файл, или база данных.

Без генератора нам придется либо вторые два источника приводить к массиву, тратя память, либо дублировать код три раза, поскольку
мы должны будем поместить его внутри цикла.

А генератор позволит обращаться ко всем трем источникам через foreach, то есть код можно будет написать только один раз.

С помощью генераторов удобно писать `бесконечные` итераторы всяких последовательностей - к примеру, четных чисел, когда каждое п
оследующее обращение к генератору будет возвращать следующий элемент из последовательности. Такое себе вычисление по-требованию,
то есть "ленивое".

Пример #1 Простой пример выдачи значений


    <?php
    function gen_one_to_three() {
        for ($i = 1; $i <= 3; $i++) {
            // Обратите внимание, что $i сохраняет своё значение между вызовами.
            yield $i;
        }
    }
    
    $generator = gen_one_to_three();
    foreach ($generator as $value) {
        echo "$value\n";
    }
    ?>

Результат выполнения данного примера:

    1
    2
    3

Пример #2 Парсим большие csv (построчный перебор)

    <?php
    function getRows($file) {
        $handle = fopen($file, 'rb');
        if ($handle === false) {
            throw new Exception();
        }
        while (feof($handle) === false) {
            yield fgetcsv($handle);
        }
        fclose($handle);
    }
    
    foreach (getRows('data.csv') as $row) {
        print_r($row);
    }

Пример #3 Попробуем решить задачу построчного чтения файла на генераторах:

    $task1 = function () {
        $fh = fopen(__DIR__ . '/test.txt', 'r');
        while (!feof($fh)) {
            yield trim(fgets($fh));
        }
    };

Первая задача представляет из себя генератор, который будет построчно читать некий файл и генерировать последовательность прочитанных строк.

Использовать генератор можно с помощью цикла foreach (совместный цикл) или явно вызывая его методы:

    foreach ($task1() as $str) {
        echo $str . PHP_EOL;
    }

### Корутины [&uarr;](#PHP)

Однако, на этом возможности генераторов не исчерпываются. Мы можем не только получать от генератора очередные значения генерируемой
им последовательности, но и передавать в генератор значения на каждом шаге! Для этого используется то же ключевое слово yield, но уже как выражение.

Давайте попробуем перевести на язык генераторов вторую задачу: "Принять строку, преобразовать ее к верхнему регистру, выдать, как
значение последовательности, ждать следующую строку":

    $task2 = function () {
        while (true) {
            $value = yield; // Приняли очередное значение извне
            yield mb_strtoupper($value); // Использовали его для генерации
        } // И так повторяем бесконечно
    };

Такой генератор, который умеет принимать извне значения, называется "`корутиной`" или, по-русски, "`сопрограммой`".

Полностью код, который будет использовать обе наши задачи, может теперь выглядеть так:

    $gen1 = $task1();
    $gen2 = $task2();
    
    while (true) {
        if (!$gen1->valid()) {
            break;
        }
        $str = $gen1->current();
        echo 'Прочитано: ' . $str . PHP_EOL;
        $str = $gen2->send($str);
        echo 'Обработано: ' . $str . PHP_EOL;
    
        $gen1->next();
        $gen2->next();
    }

Попробуйте записать какой-нибудь текст в тестовый файл и запустить этот код. Вы увидите, как первая задача-генератор читает
очередную строку из файла, значение передается второй задаче-сопрограмме, и так строчка за строчкой, пока не закончится исходный файл.

Мы реализовали с вами кооперативную многозадачность (конкурентность) - псевдопараллельное выполнение задач, основанное на том,
что задача может выполнить квант работы, прервать сама себя, сохранив своё состояние и передать управление другой задаче.

Разумеется, никакой настоящей параллельности здесь нет. Скажем, если первой задаче для кванта работы требуется одна секунда, второй
задаче для своего кванта - тоже секунда, а всего таких квантов 100, в целом программа будет выполняться минимум 200 секунд.
Мы выигрываем лишь в ресурсах (в памяти) и в возможности прервать работу, оставив ее сделанной частично. Но принципиально мы
по-прежнему находимся в рамках 2*100=200.

Конечно, нужно отметить, что мы получаем возможность работы с потенциально бесконечными задачами, что без генераторов невозможно.

### Файберы [&uarr;](#PHP)

Файберы - как еще один маленький шаг вперед

Если генераторы и сопрограммы были в PHP почти всегда (добавлены в версию 5.4) то "файберы" ("волокна" в переводе) - это новинка
недавняя, появившаяся в версии 8.1

Файберы - это способ останавливать любые функции, а не только генераторы в любом месте (в том числе во вложенных вызовах) и
возобновлять их.

Перепишем предыдущий пример с использованием файберов:

    $task1 = new Fiber(function () {
        Fiber::suspend();
        $fh = fopen(__DIR__ . '/test.txt', 'r');
        while (!feof($fh)) {
            Fiber::suspend(trim(fgets($fh)));
        }
    });
    
    $task2 = new Fiber(function () {
        $value = Fiber::suspend();
        while (true) {
            $value = Fiber::suspend(mb_strtoupper($value));
        }
    });
    
    $task1->start();
    $task2->start();
    
    while (true) {
    // Получаем от первого файбера очередную строку из файла
    $str = $task1->resume();
    
        // Если его работа закончена - закончен и наш "бесконечный" цикл
        if ($task1->isTerminated()) {
            break;
        }
    
        echo 'Прочитано: ' . $str . PHP_EOL;
    
        // Передаем прочитанную строку второй задаче, получаем от нее результат ее работы
        $str = $task2->resume($str);
        echo 'Обработано: ' . $str . PHP_EOL;
    }

Самое сложное для понимания место в этом коде - строка №12. В ней происходит та самая магия приостановки задачи.

Многоликий метод Fiber::suspend делает три дела сразу - и возвращает из задачи выходное значение ( mb_strtoupper($value) ), и
приостанавливает выполнение задачи-файбера до следующего вызова метода resume() извне задачи, и возвращает принятое извне входное
значение для следующего кванта работы файбера.

Обратите внимание, что первой строкой в каждой задаче я пишу Fiber::suspend(); Я делаю это намеренно, чтобы задачи встали на паузу
сразу же после вызова метода $task->start()

Принесли ли файберы что-то новое по сравнению с генераторами и корутинами? Да, разумеется. Появилась возможность оборачивать в
файбер любую функцию, приостанавливать ее на любом уровне вложенности с сохранением стека вызовов и контекста. Добавился удобный
объектно-ориентированный интерфейс для работы с задачами.

Является ли это новое чем-то принципиальным и революционным? Нет. Файберы, как и генераторы, реализуют конкурентность, лишь,
возможно, делая её чуть более удобной.

Равенство 2*100 = 200 по-прежнему остается актуальным, мяч у нас по-прежнему один и задачи лишь перекидывают его друг другу.

Более того, нас всё еще держит проблема блокирующего кода - если какая-то из задач решит оставить мяч у себя и не перекидывать
своей соседке, мы ничего не сможем с этим сделать...

### Проблема блокирующего кода [&uarr;](#PHP)

Итак, у нас есть задачи. Есть кванты их работы, определяемые генераторами или файберами. И мяч, который задачи перекидывают друг другу, освобождая и передавая.

Что это за мяч? Это поток исполнения. Как бы мы с вами ни старались усовершенствовать Event Loop и Concurrency - мяч всё равно один. И тот игрок (задача), который зачем-то решит задержать мяч (поток) у себя, остановит (заблокирует) всю командную игру - остальные задачи будут вынуждены его ждать.

Что же может заблокировать поток исполнения кода?

Очень много что. В первую очередь - это операции ввода-вывода. Чтение из файла? Запись в файл? Получение данных от базы? Да, разумеется. Всё это - блокирующие операции, так называемый "блокирующий I/O", то есть "ввод-вывод".

Мы не можем с вами остановиться посередине функции fgets() или метода PDO::query(). Если их выполнение началось - нужно ждать окончания, сколько бы это ни заняло времени. А мяч, точнее поток исполнения? Стоит. Ждет. Потому что эти функции синхронные и блокирующие.

Блокирующий I/O - это фундаментальная проблема. Она не зависит от операционной системы (ввод-вывод везде блокирующий), от языка программирования (он тут вообще ничего не решает) или от фреймворка.

Какой же выход? Как нам получить реальную пользу от асинхронного выполнения кода?

Выход только один - асинхронные задачи нужно запускать параллельно основному потоку исполнения. Один способ мы уже знаем - это распределенная асинхронность и использование очереди событий.

Есть ли другие способы? Да. Есть. Оказывается, можно закинуть на площадку несколько мячей.

### Реальное параллельное исполнение - процессы [&uarr;](#PHP)

Для того, чтобы нам увидеть параллельное исполнение задач, давайте их должным образом подготовим.

Пусть у нас первая задача считает числа от 1 до 25 с паузой в 1 секунду между ними, а вторая - точно также считает числа от 25 до 1,
в обратном порядке. Таким образом каждая задача выполняется 25 секунд, при последовательном или конкурентном исполнении обе
выполнятся за 50 секунд, а при реально параллельном - за те же 25.

Пишем задачи:

    $tasks = [
    
        1 => function () {
            foreach (range(1, 25, +1) as $value) {
                sleep(1);
                echo $value . PHP_EOL;
            }
        },
    
        2 => function () {
            foreach (range(25, 1, -1) as $value) {
                sleep(1);
                echo $value . PHP_EOL;
            }
        },
    
    ];

Не забываем добавить к своей установке PHP расширение pcntl и пишем код, управляющий задачами:

    foreach ($tasks as $task) {
        $pid = pcntl_fork();
        if (0 == $pid) {
            $task();
        }
    }

    pcntl_wait($status);

Что тут происходит?

Всё достаточно просто:

    - Для каждой задачи мы с помощью функции pcntl_fork() запускаем отдельный процесс, дочерний по отношению к текущему.

    - Функция pcntl_fork() вернет нам PID запущенного дочернего процесса, если мы находимся в родительском и 0, если мы в дочернем.

    - Пользуемся этой возможностью, чтобы выполнить задачу, если мы находимся в дочернем процессе.

    - С помощью функции pcntl_wait() заставляем основной процесс остановиться и дождаться окончания всех дочерних.

Запустите этот код и убедитесь, что он отрабатывает за 25 секунд. Наши задачи действительно выполняются параллельно! Это огромный плюс.

Какие минусы? Их достаточно много...

    - Создание процесса - не самая дешёвая операция, даже если мы это делаем с помощью fork();

    - Переключение контекста между процессами тоже стоит процессорного времени. Если на 4-ядерном сервере вы запустите 4 процесса или, скажем, 40 - в целом будет нормально. А вот если вы наплодите 4000 процессов - процессор большую часть времени будет переключаться между ними, а не делать полезную работу.

    - Дочерний процесс не унаследует дескрипторы - все открытые ранее файлы и сетевые соединения придется переоткрывать;

    - И, самое главное, процессам трудно общаться между друг другом. Да, есть сигналы, но это сложно назвать полноценным общением. С помощью сигналов мы не передадим значение из одной задачи в другую... Значит придется придумывать какую-то общую шину данных между процессами, например брать одно из распространенных key-value хранилищ.

Однако тот факт, что подобная многопроцессность представляет из себя полноценную многозадачность и реально параллельное выполнение
кода, причем без каких-то особых сложностей в коде - конечно, перевешивает минусы.

### Многопоточность [&uarr;](#PHP)

В современных операционных системах есть еще одно средство параллельного исполнения - это "потоки" ("threads"). Поддерживаются потоки
и в PHP, при условии их поддержки на уровне ОС.

Потоки работаю параллельно внутри одного процесса. В каждом процессе всегда есть как минимум один поток и есть возможность запустить
другие. Потоки совместно используют код и контекст - например каждый поток в случае PHP будет иметь доступ ровно к тем же классам,
функциям и глобальным переменным.

    Процесс можно сравнить с процессом приготовления блюда, а потоки - с несколькими поварами, которые работают над одним блюдом по 
    одному рецепту параллельно, распределив между собой задачи.

Когда-то давно для управления потоками в PHP требовалось собрать его инстанс с флагом ZTS (Zend Thread Safe), специальным расширением
pthreads и работать с потоками на достаточно низком уровне вызовов операционной системы.

К счастью сейчас существует новое расширение для работы с потоками - Parallel. Оно устанавливается гораздо проще (но по-прежнему
требует библиотеку pthreads в ОС) и предоставляет очень удобный интерфейс для запуска задач в отдельных потоках и для общения между
задачами.

Давайте перепишем предыдущий пример с использованием Parallel. Определение задач у нас останется прежним, изменится лишь блок их
параллельного запуска:

    $futures = [];
    foreach ($tasks as $num => $task) {
        $runtime = new parallel\Runtime();
        $futures[$num] = $runtime->run($task);
    }

Весь секрет работы с потоками заключен в объекте класса parallel\Runtime С помощью метода run() этого объекта мы запустим задачу на
параллельное исполнение в отдельном потоке. Метод run() вернет нам так называемый "фьючерс" - специальный объект
класса parallel\Future, с помощью которого мы сможем узнать статус выполняющейся задачи и получить ее результат, когда она закончит
выполняться.

Parallel устроен по умолчанию так, что наш процесс будет продолжаться до тех пор, пока не закончатся все порожденные в нем потоки,
поэтому явного вызова wait() или аналогичной функции не требуется.

Запустите код и убедитесь, что 25+25 = 25. Мы сумели в одном процессе выполнить 2 задачи действительно параллельно.

Кроме того использование потоков решает проблему блокирующих операций. Достаточно запустить задачу, требующую выполнения
блокирующего кода в отдельном потоке и, затем, занимаясь другими задачами, опрашивать поток - закончился ли он? а при окончании
получить результат его работы.

### Swoole и его go-рутины [&uarr;](#PHP)

Конечно же, говоря о многопоточности, нельзя не упомянуть Swoole - модный сейчас асинхронный фреймворк для PHP.

    Co\run(function()
    {
        go(function()
        {
            Co::sleep(1);
            echo "Done 1\n";
        });
    
        go(function()
        {
            Co::sleep(1);
            echo "Done 2\n";
        });
    });

В данном примере создается один контекст выполнения (пул задач, другими словами) и в нем запускаются две параллельные задачи.

Разумеется, Swoole не несет в себе какой-то особой магии помимо того, что мы уже изучили. В его основе лежат всё те же корутины,
файберы, если они доступны, и запуск кода в параллельных процессах.

Однако этот фреймворк привлекает качеством кода, документации, богатством возможностей и, безусловно, заслуживает изучения, если
вы интересуетесь асинхронным и параллельным PHP.
