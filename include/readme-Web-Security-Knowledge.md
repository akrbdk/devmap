# Readme

#### Список ссылок

- [SSL-сертификаты](https://doka.guide/tools/ssl-certificates/)
- [Безопасное хеширование паролей](https://www.php.net/manual/ru/faq.passwords.php)
- [CORS: история возникновения, как устроен и оптимальные методы работы](https://habr.com/ru/company/macloud/blog/553826/)





### Виды уязвимостей PHP:

#### SQL-инъекция

SQL инъекция — это один из самых доступных способов взлома сайта.
Суть таких инъекций – внедрение в данные (передаваемые через GET, POST запросы или значения Cookie) произвольного SQL кода. 
Если сайт уязвим и выполняет такие инъекции, то по сути есть возможность творить с БД (чаще всего это MySQL) что угодно.

Возможные SQL инъекции (SQL внедрения):

1. Наиболее простые — сворачивание условия WHERE к истиностному результату при любых значениях параметров.
2. Присоединение к запросу результатов другого запроса. Делается это через оператор UNION.
3. Закомментирование части запроса.

#### Межсайтовый скриптинг или XSS

XSS (Cross-Site Scripting — межсайтовый скриптинг) — распространенный тип веб-атаки, заключающийся во внедрении на страницу сайта или 
приложения вредоносного кода. Когда пользователь открывает пораженную страницу, внедренный скрипт взаимодействует с удаленным сервером злоумышленника.

![xss-8895360.png](images%2Fxss-8895360.png)

`Виды XSS-уязвимостей`

XSS-уязвимость — это брешь в защите сайта или веб-приложения, через которую злоумышленник может внедрить вредоносный код. Изначально 
основным языком, на котором создаются такие скрипты, был JavaScript. Однако теоретически для XSS-атаки можно использовать HTML, Flash и т.д. 
Главное, чтобы они исполнялись браузером жертвы.

Основная классификация XSS-уязвимостей выглядит следующим образом:

- Хранимые (постоянные). Такие уязвимости возникают, когда злоумышленнику удается получить доступ к серверу и сохранить на нем вредоносный код. Такой сохраненный скрипт будет активироваться каждый раз, когда пользователь заходит на зараженную страницу. Часто хранимые XSS-уязвимости можно найти на различных форумах, а также в соцсетях, имиджбордах, блогах и других представителях Веб 2.0. Для их внедрения на ресурс злоумышленники могут использовать обычный текст (например, в виде комментариев), рисунки, гифки и другой размещаемый контент.
- Отраженные (непостоянные). Это наиболее распространенный сегодня тип XSS-атак. Их смысл в том, что злоумышленник прячет вредоносный код в заранее подготовленной ссылке, которую потом передает пользователям-жертвам в почтовой рассылке или размещает на веб-странице. Когда пользователь переходит по зараженной ссылке, серверные скрипты исполняют ее код без обработки и возвращают его в виде ответа. Браузер пользователя исполняет зараженный скрипт, а злоумышленник получает cookies жертвы.
- DOM-модель. Суть этой уязвимости — в использовании злоумышленником Document Object Model, объектной модели документа. Это программный интерфейс, дающий программам и сценариям доступ к контенту HTML-, XHTML- и XML-документов и возможность этим содержанием (а также структурой и оформлением) управлять. XSS-уязвимости на основе DOM-модели могут быть как отраженными, так и хранимыми. Их главная особенность — сама страница сайта или веб-приложения не меняется, но меняется ее отображение в браузере пользователя из-за вредоносных модификаций DOM.

Также XSS-уязвимости различаются по степени активности:

- Активные. Такие уязвимости действуют сами независимо от активности пользователя. То есть, как только пользователь-жертва попадает на зараженную страницу, вредоносный скрипт запускается автоматически. Например, такие уязвимости встраиваются в базы данных или исполняемые файлы на сервере, в формы ввода (с помощью автоматических обработчиков событий) и т.д.
- Пассивные. В этом случае для активации вредоносного кода пользователь-жертва должен совершить какое-то действие: ввести запрос, кликнуть ссылку. Чтобы это произошло, злоумышленник должен как-то его заставить, спровоцировать или замотивировать. Здесь в ход идут методы социальной инженерии — например, фишинг.

`Как злоумышленник внедряет вредоносный код?`

Основной способ внедрения вредоносного кода на сайт или в веб-приложение — через интерактивные элементы сайта. Например, его можно разместить в строке поиска, форме обратной связи или авторизации, поле для публикации комментария. Это доступные и самые простые «точки входа» для злоумышленника, который по своей сути изначально является одним из посетителей ресурса.

Для внедрения вредоносного скрипта злоумышленник может использовать следующие каналы или векторы атаки, то есть точки проникновения в защиту сайта или веб-приложения.

`Ошибки в браузере`. Это уязвимости самих браузерных программ, которыми пользуются посетители сайтов. Типичный пример — выполнение сценариев на языке SVG, которое позволяет обойти правило ограниченного домена. Как правило, такие серьезные ошибки быстро устраняются разработчиками браузеров. Однако есть и более узкоспециализированные уязвимости, которые могут оставаться незамеченными годами. В таких случаях проще настроить защиту на самом сайте, чем ждать обновления браузерной программы.

`Отсутствие экранирования`. Одной из проблем современных браузеров является их неспособность отличить обычный текст от кода. То есть чтобы браузерная программа распознала и выполнила код HTML, он должен быть размечен тегами. Соответственно, Java-скрипты должны помещаться между тегами <script>, CSS-стили — между CSS и т.д.

Но если браузер воспринимает размеченный соответствующим образом текст как код, то он начинает исполнять и аналогично оформленный текст, размещенный на сайте сторонними пользователями, среди которых может быть и злоумышленник. Типичной целью являются поля, в которых размещаются комментарии. Чтобы браузер воспринимал текст от пользователей как обычный текст (даже если он размечен как код), предварительно настраивается его экранирование — например, автоматическая замена спецсимволов, используемых в языках разметки и программирования, на «аналоги», которые не учитываются браузером.

К сожалению, экранирование присутствует на сайтах и в веб-приложениях не всегда, и причин может быть несколько:

- Программист элементарно забывает настроить экранирование во всех интерактивных формах на сайте, особенно если ресурс большой.
- Разные страницы и разделы сайта создаются разными специалистами и в разное время, что еще больше увеличивает вероятность ошибки.
- Уязвимость допущена в коде библиотеки или фреймворка, который используется разработчиком при создании или доработке сайта.

Подмена кодировки в заголовке страницы. Современные браузеры определяют кодировку прямо по ходу обработки страницы. Кодировка отображается в теге <meta>, и если тег <title> расположен до него, то сначала браузерная программа прочитает и обработает заголовок, а уже потом определит, какая кодировка используется на сайте. Соответственно, у злоумышленника появляется возможность обойти фильтрацию служебных символов < и “, разместив в тайтле вредоносный код, закодированный в UTF-7.

SiXSS (межсайтовый скриптинг при наличии SQL-инъекции). Это комбинированный тип атаки, задействующий базу данных сайта. Работает это следующим образом. С помощью SQL-инъекции злоумышленник внедряет вредоносный код в одну из страниц БД. Если на сайте отсутствует экранирование при выводе содержимого базы данных, то при доступе к «отравленной» строке БД вредоносный скрипт попадает в браузер пользователя.

Перечисленные векторы атаки — самые распространенные. На практике способов, которыми злоумышленники могут внедрить код на сайт или в веб-приложение, гораздо больше. Какие-то из них работают на всех типах ресурсов, другие отличаются узкой специализацией. Такое разнообразие приводит к тому, что гарантированной и 100-процентной защиты от XSS-угроз не существует.

`Последствия XSS-атаки`

Сами XSS-уязвимости опасности для самого ресурса или его пользователей не представляют. Угрозу несут именно атаки, для которых эти бреши в обороне являются «точками входа». С помощью XSS-атаки можно нанести ресурсу и его пользователям разнообразный вред.

Кража пользовательских данных. Сайты и приложения, на которых предусмотрена авторизация пользователей, отличают авторизованного посетителя от неавторизованного с помощью специального cookie-файла (сессионной cookie). Этот файл будет видеть только авторизованный посетитель, а еще — любой JavaScript-код, исполняемый его браузером (в том числе и помещенный на страницу злоумышленником). Прочитав сессионную cookie жертвы, вредоносный скрипт через AJAX-запрос передает данные авторизации на удаленный сервер, предварительно созданный злоумышленником. Там эта информация заносится в базу данных, и хакеру остается только вычленить ее из параметров URL. Это дает злоумышленнику следующие возможности:

- похитить конфиденциальные данные пользователя: историю посещений, информацию по платежным картам, личную переписку и т.д.;
- использовать аккаунт пользователя-жертвы для рассылки спама, угроз и другого противоправного контента, публикации комментариев с противозаконным или компрометирующим содержанием;
- рассылать вредоносные программы другим пользователям, особенно тем, у кого пользователь-жертва пользовался доверием;
- получить бесплатный доступ к платному контенту: учебным курсам, мультимедийному контенту и т.д.

Доступ к управлению сайтом. Злоумышленник может завладеть не только данными авторизованных пользователей, но и правами администратора сайта/веб-приложения. В этом случае он получает доступ к панели управления ресурсом и может контролировать его содержание, структуру, оформление. Такие возможности позволяют злоумышленнику:

- получить авторизационные данные любого зарегистрированного на сайте пользователя;
- испортить функционал и/или оформление сайта с целью его дискредитации в глазах настоящих или потенциальных посетителей;
- разместить на ресурсе посторонний, противозаконный или компрометирующий контент, внести изменения в уже имеющееся содержание (пресс-релизы, статьи, описания товаров и т.д.);
- взломать корпоративную базу данных для получения конфиденциальной информации (секретных технологий, сведений о коммерческой деятельности и т.д.).

Опасность не ограничивается лишь потерей или кражей данных, репутационными издержками — последствия могут быть куда серьезнее. Например, если злоумышленник получает на сайте фармацевтической компании доступ к описанию лекарства, он может изменить информацию по дозировке сильнодействующего лекарства. Как результат — массовые интоксикации с тяжелыми последствиями вплоть до летальных исходов.

`Защита от XSS-атак`


- настроить фильтрацию и экранизацию входных параметров, то есть информации, вводимой пользователем через интерактивные поля и формы;
- настроить автоматическую замену спецсимволов, чтобы четко отделить пользовательский текст от исполняемого кода;
- на каждой странице сайта разместить кодировку перед какими-либо пользовательскими полями;
- установить ограничения домена и путей приема cookie-файлов с помощью SSL или параметра HttpOnly;
- регулярно проверять сайт или веб-приложение на уязвимости такими инструментами, как Nessus, Nikto Web Scanner и т.д.;
- задать список желательных источников для загрузки контента с помощью заголовка Content Security Policy;
- регулярно обновлять браузер до актуальной версии и использовать расширения для проверки URL, скриптов, интерактивных форм и других потенциальных источников угроз.


#### Демонстрация ошибок пользователю

Смысл: при каких-либо ошибках в коде пользователю выводиться информация об произошедшей ошибке. Не является критичной уязвимостью, но поваляет взломщику получить дополнительную информацию о структуре и работе сервера.


#### Доступность данных о характеристиках системы пользователю

Смысл: пользователь может получить доступ к данным, дающим представление о системе. Не является критичной уязвимостью, но поваляет 
взломщику получить дополнительную информацию о структуре и работе сервера. Причина этой уязвимости в ошибках и «недосмотрах» программиста. Примером может служить наличие файла phpinfo.php с одноимённой функцией в свободном доступе.


#### Доступность данных о программном коде пользователю

Смысл: пользователь может получить доступ к программным кодам модулей, имеющих расширение, отличное от php. Является критичной уязвимостью, так как позваляет взломщику получить достаточно полную информацию о структуре и работе сервера, выявить его уязвимости.

#### Простые пароли для доступа к административным страницам

Смысл: взломщик может подобрать простой пароль к административной странице, дающей ему больше возможностей для взлома. Является критичной уязвимостью, так как позваляет взломщику повлиять на работу сервера.

#### Возможность задания глобальных переменных

Смысл: при неправильных настройках PHP имеется возможность задавать глобальные переменные скрипта, через строку запроса. Является критичной уязвимостью, так как взломщик может влиять на ход работы скрипта в свою пользу.

#### PHP-инъекция

Смысл: в параметр, определяющий работу PHP с файлами или программным кодом, передаётся ссылка на сторонний программный код или сам код. Является критичной уязвимостью, так как взломщик может выполнять свои скрипты на сервере. Выполнение кода осуществляется при помощи функций: eval(), preg_replace(), require_once(), include_once(), include(), require(), create_function(), readfile(), dir(), fopen().

#### PHP-инъекция через загрузку файлов

Смысл: при возможности задании глобальных переменных в параметр, определяющий загружаемый на сервер файл, передаётся ссылка на сторонний программный код или конфиденциальный файл на сервере. Является критичной уязвимостью, так как взломщик может выполнять свои скрипты на сервере или получить доступ к конфиденциальным данным. Данная уязвимость возможна только при возможности задания глобальных переменных и неверной организации механизма загрузки файлов.

#### e-mail-инъекция

Смысл: в параметр, определяющий работу PHP с электронными письмами, передаётся ссылка на сторонний программный код или сам код. Является критичной уязвимостью, так как взломщик может выполнять свои скрипты на сервере или получить доступ к данным, хранимым у пользователя.

#### SQL-инъекция

Смысл: в параметр, определяющий SQL-запрос, передаётся данные, образующее запрос для доступа к закрытым данным. Является критичной уязвимостью, так как взломщик может получить конфиденциальные данные, хранимые в базе данных. Для изменения запроса взломщик может использовать следующие конструкции: SELECT, UNION, UPDATE, INSERT, OR, AND.

#### Межсайтовый скриптинг или XSS

Смысл: в параметр, определяющий выводимые пользователю данные, передаётся сторонний программный код. Является критичной уязвимостью, так как взломщик может получить конфиденциальные данные, хранимые в браузере клиента. Для изменения запроса взломщик использует html-теги.


### Правила написания безопасного кода на PHP



#### Блокирование вывода ошибок

Для этого достаточно в программном коде задать error_reporting(0) или в файле .htaccess добавить строку php_flag error_reporting 0

#### Использование сложных паролей для доступа к административным страницам

Для этого достаточно использовать многозначные пароли, не имеющие семантического значения (например, К7O0iV98dq).

#### Логирование критических действий пользователя

Не обеспечивает защиту напрямую, но позволяет выявить взломщиков и определить уязвимости, которые они использовали. Для этого действия 
пользователя и переданные им данные, которые касаются критических моментов работы системы, достаточно записывать в обычный текстовый файл.

#### Закрытие доступа к модулям сайта

Обеспечивает защиту от попыток просмотра их содержимого или выполнения. Для этого достаточно в файле .htaccess настроить доступ к файлам модулей при помощи конструкций FilesMatch и Files.

#### Отключение возможности задания глобальных переменных

Для этого достаточно в настройках сервера задать register_globals = off; или в файле .htaccess добавить строку php_flag register_globals off. Использование ini_set('register_globals',0); проблему не решит так, как переменные задаются до начала выполнения скрипта.

#### Отключение возможности использования удаленных файлов

Для этого достаточно в настройках сервера задать allow_url_fopen = off;. Это обеспечивает частичную защиту от PHP-инъекций, но не полную, так как взломщик может передавать не ссылку на файл с программным кодом, а сам программный код. Для полной защиты от PHP-инъекций необходимо дополнительно использовать фильтрацию поступивших данных. Иногда данную меру защиты невозможно использовать из-за особенностей работы проекта (нужно обращаться к удалённым файлам).

#### Фильтрация поступающих данных

Обеспечивает защиту от большенства уязвимостей. Универсального решения не существует. Желательно использовать проверку по «белому» списку символов в совокупности с проверкой на запрещённые слова. «Белым» называется список разрешенных символов. В этот список не должны входить опасные символы, например, <>. К запрещённым словам можно отнести: script, http, SELECT, UNION, UPDATE, exe, exec, INSERT, tmp, а также html-теги.

Пример фильтрации поступающих данных:
    
    // Проверка по белому списку. Допускаются только русские и латинские буквы, цифры и знаки _- <br/>
    if (preg_match("/[^(\w)|(А-Яа-я-)|(\s)]/",$text)) {<br/>
      $text = '';<br/>
    }<br/>
    // Фильтрация опасных слов<br/>
    if (preg_match("/script|http|<|>|<|>|SELECT|UNION|UPDATE|exe|exec|INSERT|tmp/i",$text)) {<br/>
      $text = '';<br/>
    }

#### Проверка на загрузку файла при помощи HTTP POST

Обеспечивает защиту от PHP-инъекций через загрузку файлов. Для обеспечения этого загруженные на сервер файлы необходимо 
проверять функцией is_uploaded_file() или перемещать функцией move_uploaded_file(). Данный вид защиты можно не использовать, если отключена 
возможность задания глобальных переменных.

#### Экранирование символов кавычек данных, передаваемых в базу данных

Обеспечивает защиту от SQL-инъекций. Наиболее оптимальным методом является обработка всех поступивших не числовых данных с помощью функции 
mysql_real_escape_string(). Можно так же использовать автоматическое экранирование, поступающих данных. Для этого достаточно в файле .htaccess 
добавить строку php_value magic_quotes_gpc on, но этот способ не является надёжным, так как может привести к двойному экранированию.

Пример экранирования кавычек с помощью функции mysql_real_escape_string():

    if (!is_numeric($text)) {<br/>
      $textrequest = mysql_real_escape_string($text);<br/>
    }

#### Преобразование специальных символов в html-сущности перед выводом

Обеспечивает защиту от XSS. Для этого данные, введенные пользователем, которые могут содержать нежелательные html-тэги, при выводе 
достаточно обработать функцией htmlspecialchars(). Данный вид защиты можно не использовать, если фильтрация поступающих данных отсеивает опасные html-тэги.



### HTTPS [&uarr;](#Readme)

HTTPS (от англ. HyperText Transfer Protocol Secure) – расширение протокола HTTP, которое используется для шифрования и
безопасного обмена данными между пользователем и сайтом. Вся информация шифруется с помощью криптографических протоколов
TSL или его предшественника SSL. Википедия рулит! Если не уходить глубоко в технические подробности, то HTTPS шифрует
данные и не дает возможности их перехватить.

Принципом работы защищённого протокола HTTPS является обмен ключами шифрования. Прежде чем ответить на запрос от
браузера, сервер предъявляет ключ — SSL-certificate. Браузер проверяет подлинность ключа в Центре сертификации. Если
ключ «подошёл», браузер и сервер доверяют друг другу и договариваются о разовом шифре. Так происходит каждую сессию, то
есть каждый раз при обмене запросами и ответами. Вот таким хитрым способом и обеспечивается сохранность данных и
конфиденциальность при обмене информацией.

Как это работает? Как только Вы зашли на сайт, то Ваш браузер получает от сервера сертификат, в котором есть вся
информация о сайте, его владельце, кем выдан и еще много всего. Самое главное, Ваш браузер получает открытый ключ, по
которому он начнет шифровать все данные. На сервере стоит закрытый ключ, с помощью которого можно расшифровать всю
информацию.

Если кто-то захочет перехватить или получить конфиденциальные данные, то он сможет увидеть только набор с непонятных
символов, на расшифровку которых потребуется несколько лет. За это время сертификат устареет, и в итоге злоумышленник
ничего не получит.

#### Зачем нужен SSL-сертификат для сайта

    Чтобы сайт стал работать по протоколу безопасного соединения HТТPS, нужен SSL-сертификат. Это виртуальный документ, который содержит данные об организации, её владельце и подтверждает их существование. Позволяет узнать сервер и подтвердить безопасность сайта.

    Использование сертификата безопасности для сайта гарантирует:

        Подлинность ресурса, к которому обращается пользователь. Это повышает у посетителей уровень доверия.
        Целостность передаваемой информации. При транспортировке от сервера к браузеру данные не изменятся и не потеряются.
        Конфиденциальность. 256-разрядное шифрование исключает доступ злоумышленников к информации.

    Что дает SSL-сертификат для сайта кроме защиты данных? SSL-сертификат помогает в SEO-продвижении проекта — позволяет занять более высокую позицию в поисковой выдаче. Поисковые системы (Google, Яндекс и пр.) дорожат доверием аудитории и выше ранжируют сайты, которые работают через безопасное соединение.


### OWASP Security Risks [&uarr;](#Readme)

OWASP (расшифровывается как Open Web Application Security Project) — это онлайн-сообщество, которое выпускает статьи на тему 
безопасности веб-приложений, а также документацию, различные инструменты и технологии.

OWASP Топ-10 — это список из десяти самых распространённых на данный момент уязвимостей веб-приложений. Благодаря этому списку пользователи будут осведомлены о наиболее критичных рисках и угрозах, их последствиях и мерах противодействия. Обновляется список OWASP каждые три-четыре года (последний раз он был выпущен в 2018 году). Давайте познакомимся с ним поближе.

10 основных уязвимостей OWASP 2020 года:

- Инъекционные атаки (Injections)
- Нарушенная аутентификация (Broken Authentication)
- Незащищённость критичных данных (Sensitive Data Exposure)
- Внешние объекты XML (XXE) (XML External Entities (XXE))
- Нарушение контроля доступа (Broken Access control)
- Небезопасная конфигурация (Security misconfigurations)
- Межсайтовый скриптинг (XSS) (Cross Site Scripting (XSS))
- Небезопасная десериализация (Insecure Deserialization)
- Использование компонентов с известными уязвимостями (Using Components with known vulnerabilities)
- Неэффективный мониторинг (Insufficient logging and monitoring)

### CORS [&uarr;](#Readme)


Ошибка в консоли вашего браузера

    No ‘Access-Control-Allow-Origin’ header is present on the requested resource.

    Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://example.com/

    Access to fetch at ‘https://example.com’ from origin ‘http://localhost:3000’ has been blocked by CORS policy.

Это примеры CORS-ошибок.CORS — это невероятно полезный механизм в мире неправильно настроенных веб серверов,
злоумышленников, орудующих в интернете и организаций, продвигающих веб-стандарты.

Если браузер запрашивает тег из источника, который отличается от получателя по схеме, в полностью определенному имени
хоста или порту, то это и есть запрос между различными источниками (cross-origin request).

Источники & cross-origin

Источник идентифицируется следующей тройкой параметров: схема, полностью определенное имя хоста и порт.
Например, <http://example.com> и <https://example.com> имеют разные источники: первый использует схему http, а второй
https. Вдобавок, портом для http по умолчанию является 80, тогда как для https — 443. Следовательно, в данном примере 2
источника отличаются схемой и портом, тогда как хост один и тот же (example.com).

Таким образом, если хотя бы один из трех элементов у двух ресурсов отличается, то источник ресурсов также считается
разным.

CORS — это механизм, который дает контролировать доступ к тегам на веб странице по сети. Механизм классифицируется на
три разные категории доступа тегов:

    - Запись из разных источников
    - Вставка из разных источников 
    - Считывание из разных источников 

Вставки из разных источников — это теги, загружаемые через `<script>, <link>, <img>, <video>, <audio>, <object>, <embed>, <iframe>`
и т.п. Все они разрешены по умолчанию. `<iframe>` выделяется на их фоне, так как он используется для загрузки
другой страницы внутри фрейма. Его обрамление в зависимости от источника может регулироваться посредством использования
заголовка X-Frame-options.

Что касается `<img>` и других вставных тегов, то они устроены так, что сами инициируют запросы из разных источников
cross-origin запроса. Именно поэтому в CORS существует различие между вставкой из разных источников и считыванием из
разных источников.

Считывание из разных источников — это теги, загружаемые через вызовы AJAX/ fetch. Все они по умолчанию заблокированы
вашим браузером. Существует обходной путь для вставки таких тегов на странице, но такие трюки регулируются другой
политикой, которая соблюдается в современных браузерах.


### SSL/TLS [&uarr;](#Readme)


Сертификат SSL/TLS — это цифровой объект, который позволяет системам проверять личность и впоследствии устанавливать зашифрованное сетевое соединение с другой системой с использованием протокола Secure Sockets Layer/Transport Layer Security (SSL/TLS). Сертификаты используются в рамках криптографической системы, известной как инфраструктура открытого ключа (PKI). PKI дает одной стороне возможность устанавливать подлинность другой стороны с помощью сертификатов (при условии, что обе стороны доверяют третьей стороне, известной как центр сертификации). Таким образом, сертификаты SSL/TLS действуют как цифровые удостоверения личности для защиты сетевых подключений и установления подлинности веб-сайтов в Интернете, а также ресурсов в частных сетях.
Почему сертификаты SSL/TLS важны?

Сертификаты SSL/TLS укрепляют доверие среди пользователей веб-сайта. Компании устанавливают сертификаты SSL/TLS на веб-серверы для создания веб-сайтов, защищенных SSL/TLS. Характеристики веб-страницы, защищенной SSL/TLS, следующие:

- Значок замка и зеленая адресная строка в веб-браузере
- Префикс https в адресе веб-сайта в браузере
- Действующий сертификат SSL/TLS Вы можете проверить, действителен ли сертификат SSL/TLS, щелкнув и развернув значок замка в адресной строке URL-адреса.
- После установления зашифрованного соединения только клиент и веб-сервер могут видеть отправленные данные.

Ппреимущества сертификатов SSL/TLS.

#### Защищает личные данные

Браузеры проверяют сертификат SSL/TLS любого веб-сайта для запуска и поддержания безопасного соединения с сервером веб-сайта. 
Технология SSL/TLS помогает обеспечить шифрование всей связи между вашим браузером и веб-сайтом.

#### Укрепляйте доверие клиентов

Подкованные в Интернете клиенты понимают важность конфиденциальности и хотят доверять посещаемым веб-сайтам. Веб-сайт, защищенный SSL/TLS, 
имеет зеленый значок замка, который клиенты считают безопасным. Защита SSL/TLS помогает клиентам понять, что их данные защищены, когда
они передают их вашему бизнесу.

#### Соответствие нормативным требованиям

Некоторые компании должны соблюдать отраслевые нормы конфиденциальности и защиты данных. Например, компании, работающие в индустрии 
платежных карт, должны придерживаться PCI DSS. PCI DSS — это отраслевое требование для обеспечения безопасных онлайн-транзакций, включая 
защиту веб-сервера сертификатом SSL/TLS.

#### Улучшить SEO

Крупные поисковые системы сделали защиту SSL/TLS фактором ранжирования для поисковой оптимизации. Веб-сайт, защищенный SSL/TLS, скорее 
всего, будет занимать более высокое место в поисковой системе, чем аналогичный веб-сайт без сертификата SSL/TLS. Это увеличивает количество
посетителей из поисковых систем на веб-сайт, защищенный SSL/TLS.

#### Как работает сертификат SSL/TLS?

Браузеры используют сертификат SSL/TLS для запуска безопасного соединения с веб-сервером с помощью рукопожатия SSL/TLS. 
Рукопожатие SSL/TLS является частью технологии защищенной связи протокола передачи гипертекста (HTTPS). Это комбинация HTTP и SSL/TLS. 
HTTP – это протокол, который веб-браузеры используют для отправки информации в виде обычного текста на веб-сервер. HTTP передает 
незашифрованные данные, что означает, что информация, отправленная из браузера, может быть перехвачена и прочитана третьими лицами. 
Браузеры используют HTTP с SSL/TLS или HTTPS для полностью безопасной связи.

Рукопожатие SSL/TLS включает в себя следующие шаги:

- Браузер открывает защищенный SSL/TLS веб-сайт и подключается к веб-серверу.
- Браузер пытается проверить подлинность веб-сервера, запрашивая идентифицирующую информацию. 
- В ответ веб-сервер отправляет сертификат SSL/TLS, содержащий открытый ключ.
- Браузер проверяет сертификат SSL/TLS, проверяя, что он действителен и соответствует домену веб-сайта. Как только браузер удовлетворен сертификатом SSL/TLS, он использует открытый ключ для шифрования и отправки сообщения, содержащего секретный ключ сеанса.
- Веб-сервер использует свой закрытый ключ для расшифровки сообщения и получения ключа сеанса. Затем сеансовый ключ используется для шифрования и отправки подтверждающего сообщения в браузер.
- Теперь и браузер, и веб-сервер переходят на использование одного и того же сеансового ключа для безопасного обмена сообщениями. 


### Content Security Policy (CSP) [&uarr;](#Readme)

CSP (Content Security Policy) — стандарт защиты сайтов от атак с внедрением контента, например XSS — межсайтового скриптинга. 
CSP описывает безопасные источники загрузки и блокирует ресурсы, которые не входят в «белый список».

#### Для чего нужен CSP

По политике безопасности в интернете, каждый сайт должен обращаться только к своим данным (same-origin policy). На практике ресурсы 
постоянно взаимодействуют с другими источниками: социальными сетями, сервисами метрики, сетями доставки контента и т.д. Это используют 
злоумышленники. Они внедряют вредоносный код в подгружаемую на сайт внешнюю информацию, которую он считает безопасной. Цель CSP — ограничить
список ресурсов, откуда может загружаться контент, например изображения для страницы.

#### Как работает CSP

Стандарт CSP сообщает сайту, какие источники данных заслуживают доверия, а какие — нет. Он работает по принципу «Что не разрешено (не упомянуто), то запрещено». Для этого на страницу добавляется HTTP-заголовок Content-Security-Policy и директивы. Каждая директива представляет собой «белый список», в котором через пробел прописаны источники контента. Администратор может дать доступ целому домену, его отдельным поддоменам или конкретной странице, уточнить допустимые правила взаимодействия с ними.
Основные директивы

- img-src — контролирует использование изображений с внешних ресурсов;
- media-src — управляет загрузкой медиаконтента (видео, анимации, аудио);
- script-src — ограничивает источники рабочих сценариев для веб-страницы;
- frame-src — контролирует подгрузку веб-элементов, вложенных в контекст основной страницы;
- default-src — резервная директива. Когда браузер или другая программа для работы с веб-страницами просматривает код сайта, то сначала анализирует содержание частных директив. Если информации нет, то обращается к резервной директиве. Например, браузер не «увидел» в img-src источники, из которых можно подгружать изображения. Тогда он обращается к default-src и использует указанный там список. 


#### Правила

- none — запрещает использование ресурсов из всех источников, включая домен сайта;
- self — разрешает подгружать ресурсы, размещенные на домене защищаемого сайта.

Для каждой директивы должны быть прописаны значения. При этом правил из одной директивы не влияют на указанные в другой. Например, если на сайте в img-src помечено self, а в default-src — self и адрес http://cdn.example.com, то картинки будут загружаться только с собственного домена сайта.

Кроме источников, в директивах также прописываются правила:

- unsafe-inline — разрешает использование инлайн-стилей (когда стиль указан не в отдельном блоке/файле, а непосредственно в коде) и скриптов style и script, атрибутов CSS style, обработчиков событий (onclick, onmouseover и т.д.) и javascript-ссылок. Если это правило не прописано, все они запрещаются автоматически;
- unsafe-eval — применяется в директиве script-src. Когда этого правила нет, запрещается любая динамическая оценка кода (при выполнении).

Разработчики и системные администраторы, которые еще не решили, стоит ли внедрять CSP на сайтах, могут применять директиву Content-Security-Policy-Report-Only. В этом случае система защиты будет отмечать нарушения безопасности и отправлять CSP-отчеты, но не станет блокировать использование ресурсов даже из потенциально опасных источников.

Пример 1

    Ограничение источников контента только исходным сервером (без поддоменов).
    Content-Security-Policy: default-src 'self'

Пример 2

    Можно получать контент с только с доверенного домена и его поддоменов.
    Content-Security-Policy: default-src 'self' *.trusted.com

Пример 3

    Пользователи приложения могут вставлять в контент изображения из любых источников, но при этом загружать аудио- и видеофайлы только от доверенных провайдеров. Скрипты можно получать только с конкретного сервера, который содержит доверенный код.
    Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com

- Изображения будут доступны из любого источника (источник — «*»).
- Прочие медиафайлы — с media1.com и media2.com (без поддоменов).
- Исполняемый код — с userscripts.example.com.

#### От каких атак защищает CSP

`XSS (Cross-Site Scripting) — «межсайтовый скриптинг»`

На страницу сайта внедряется вредоносный код, связанный с сервером злоумышленника. Браузер доверяет источнику контента и выполняет директивы.

Как защищает CSP: администраторы сервера, на котором расположен сайт, могут составить «белый список» доменов, заслуживающих доверия. Так можно сократить или полностью исключить обращение к источникам потенциально вредоносного скрипта. Радикальный вариант защиты — глобальный запрет на исполнение скриптов.


`Перехват пакетов`

Это извлечение конкретных данных из общего потока информации между сайтом и компьютером пользователя. Используется вредоносный код, внедренный в протоколы передачи данных. Могут быть перехвачены и похищены сетевые пароли, номера банковских карт или телефонные номера, указанные при оформлении заказов.

Как защищает CSP: сервер может указать, какие протоколы разрешено использовать. Стратегия безопасности передачи данных отмечает файлы cookie атрибутами secure и автоматически перенаправляет со страниц HTTP на их аналоги HTTPS. Сайты также могут использовать HTTP-заголовок Strict-Transport-Security, чтобы браузеры подключались по зашифрованному каналу. От перехвата пакетов это не защитит, но поможет избежать расшифровки.

#### Как включить на сайте?

Переключив CSP Tester в Advanced mode, можно увидеть составленную политику в виде текстовой строки. Теперь ее можно добавить в .htaccess:

    <IfModule mod_headers.c>
      Header set Content-Security-Policy "..."
    </IfModule>

Например:

    <IfModule mod_headers.c>
      Header set Content-Security-Policy "default-src 'self'; script-src *.google-analytics.com 'self'; object-src 'self'; style-src 'self'; img-src *; frame-src 'self'"
    </IfModule>

Отключаем расширение, загружаем сайт, убеждаемся, что заголовок Content-Security-Policy приходит и еще раз проверяем, нет ли ошибок в консоли.



### Server Security [&uarr;](#Readme)


Learn about the security of your server and how to secure it. Here are some of the topics off the top of my head:

- Use a firewall: One of the most effective ways to secure a server is to use a firewall to block all unnecessary incoming traffic. You can use iptables on Linux systems or a hardware firewall to do this.
- Close unnecessary ports: Make sure to close any ports that are not needed for your server to function properly. This will reduce the attack surface of your server and make it more difficult for attackers to gain access.
- Use strong passwords: Use long, complex passwords for all of your accounts, and consider using a password manager to store them securely.
- Keep your system up to date: Make sure to keep your operating system and software up to date with the latest security patches. This will help to prevent vulnerabilities from being exploited by attackers.
- Use SSL/TLS for communication: Use Secure Sockets Layer (SSL) or Transport Layer Security (TLS) to encrypt communication between your server and client devices. This will help to protect against man-in-the-middle attacks and other types of cyber threats.
- Use a intrusion detection system (IDS): An IDS monitors network traffic and alerts you to any suspicious activity, which can help you to identify and respond to potential threats in a timely manner.
- Enable two-factor authentication: Two-factor authentication adds an extra layer of security to your accounts by requiring a second form of authentication, such as a code sent to your phone, in addition to your password.


### Хэш-алгоритмы [&uarr;](#Readme)

Хеширование — это преобразование информации с помощью особых математических формул. В результате возникает хеш — отображение
данных в виде короткой строки, в идеале — уникальной для каждого набора информации. Размер строки может быть одинаковым для
информации разного объема.

Хеш — это не закодированная исходная информация. Это скорее уникальная метка, которая генерируется для каждого набора данных
индивидуально. Если захешировать большую книгу и одно слово, получатся хеши одинаковой длины. А если изменить в слове одну букву и снова захешировать полученную строку, новый хеш будет совершенно другим, там не окажется участков, которые повторяли бы предыдущий.

Математические алгоритмы, по которым хешируется информация, называются хеш-функциями. Их название тоже иногда сокращают как «хеш».
Хеш-функций существует очень много, они различаются методами вычислений, назначением, надежностью и другими параметрами.

Кто работает с хешированием

    - IT-специалисты, разработки которых хранят чувствительную конфиденциальную информацию. Например, в веб-разработке хеши обычно нужны для проверки паролей. Вместо них на сервере хранятся хеши, а когда пользователь вводит пароль, тот автоматически хешируется, и хеш сравнивается с сохраненным на сервере.
    - Разработчики, имеющие дело со сложными структурами данных, такими как ассоциативные массивы и хеш-таблицы.
    - Люди, которые имеют дело с криптовалютой. В этой сфере активно используется хеширование как удобный способ проверки подлинности данных. На алгоритмах хеширования во многом построен блокчейн.
    - Этичные хакеры и специалисты по информационной безопасности для обеспечения конфиденциальности данных или, наоборот, для проверки той или иной информации. Например, конкретный вирус можно распознать по характерному хешу.

Для чего нужно хеширование

Основное назначение хеширования — проверка информации. Эта задача важна в огромном количестве случаев: от проверки паролей на сайте
до сложных вычислений в блокчейне. Так как хеш — это уникальный код определенного набора данных, по нему можно понять, соответствует
ли информация ожидаемой. Поэтому программа может хранить хеши вместо образца данных для сравнения. Это может быть нужно для защиты
чувствительных сведений или экономии места.

Вот несколько примеров:

    - вместо паролей на сервере хранятся хеши паролей;
    - антивирус хранит в базе хеши вирусов, а не образцы самих программ;
    - электронная подпись использует хеш для верификации;
    - информация о транзакциях криптовалюты хранится в виде кешей;
    - коммиты в Git идентифицируются по хешу (подробнее про Git и коммиты можно прочесть в нашей статье).

Среди других, менее распространенных примеров использования — поиск дубликатов в больших массивах информации, генерация ID и
построение особых структур данных. Это, например, хеш-таблицы — в них идентификатором элемента является его хеш, и он же определяет
расположение элемента в таблице.

Почему популярные хеширующие функции, такие как md5() и sha1() не подходят для паролей?

    Такие хеширующие алгоритмы как MD5, SHA1 и SHA256 были спроектированы очень быстрыми и эффективными. При наличии современных технологий и оборудования, стало довольно просто выяснить результат этих алгоритмов методом "грубой силы" для определения оригинальных вводимых данных.

    Из-за той скорости, с которой современные компьютеры могут "обратить" эти хеширующие алгоритмы, многие профессионалы компьютерной безопасности строго не рекомендуют использовать их для хеширования паролей.

Если популярные хеширующие функции не подходят, как же я тогда должен хешировать свои пароли?

    При хешировании паролей существует два важных соображения: это стоимость вычисления и соль. Чем выше стоимость вычисления хеширующего алгоритма, тем больше времени требуется для взлома его вывода методом "грубой силы".

    PHP предоставляет встроенное API хеширования паролей, которое безопасно работает и с хешированием и с проверкой паролей.

    Другой возможностью является функция crypt(), которая поддерживает несколько алгоритмов хеширования. При использовании этой функции вы можете быть уверенным, что выбранный вами алгоритм доступен, так как PHP содержит собственную реализацию каждого поддерживаемого алгоритма, даже в случае, если какие-то из них не поддерживаются вашей системой.

    При хешировании паролей рекомендуется применять алгоритм Blowfish, который также используется по умолчанию в API хеширования паролей, так как он значительно большей вычислительной сложности, чем MD5 или SHA1, при этом по-прежнему гибок.

    Учтите, что, если вы используете функцию crypt() для проверки пароля, то вам нужно предостеречь себя от атак по времени, применяя сравнение строк, которое занимает постоянное время. Ни операторы PHP == и ===, ни функция strcmp() не являются таковыми. Функция же password_verify() как раз делает то, что нужно. Настоятельно рекомендуется использовать встроенное API хеширования паролей, если есть такая возможность.

Функции хеширования паролей

    password_algos — Получает доступные идентификаторы алгоритма хеширования пароля
    password_get_info — Возвращает информацию о заданном хеше
    password_hash — Создаёт хеш пароля
    password_needs_rehash — Проверяет, что указанный хеш соответствует заданным опциям
    password_verify — Проверяет, соответствует ли пароль хешу


Что такое соль?

    Криптографическая соль представляет собой данные, которые применяются в процессе хеширования для предотвращения возможности разгадать оригинальный ввод с помощью поиска результата хеширования в списке заранее вычисленных пар ввод-хеш, известном также как "радужная" таблица.

    Более простыми словами, соль - это кусочек дополнительных данных, которые делают ваши хеши намного более устойчивыми к взлому. Существует много онлайн-сервисов, предоставляющих обширные списки заранее вычисленных хешей вместе с их оригинальным вводом. Использование соли делает поиск результирующего хеша в таком списке маловероятным или даже невозможным.

    password_hash() создаёт случайную соль в случае, если она не была передана, и чаще всего это наилучший и безопасный выбор.

Как я должен хранить свою соль?

    При использовании функции password_hash() или crypt(), возвращаемое значение уже содержит соль как часть созданного хеша. Это значение нужно хранить как есть в вашей базе данных, так как оно содержит также информацию о хеширующей функции, которая использовалась, и может быть непосредственно передано в функции password_verify() или crypt() при проверке пароля.

    Следующая диаграмма показывает формат возвращаемого значения функциями crypt() или password_hash(). Как можно видеть, они содержат полную информацию об алгоритме и соли, требуемых для будущей проверки пароля. 

![](images/2023-02-20_17-17-51.png)
