# Readme

#### Список ссылок

- [Асинхронный веб, или Что такое веб-сокеты](https://tproger.ru/translations/what-are-web-sockets/)
- [Работа с Веб-сокетами на PHP](https://habr.com/ru/post/709448/)
- [HTTP запросы и AJAX: short-polling, long-polling, websockets и все-все-все](https://vk.com/@social_it-http-zaprosy-i-ajax-short-polling-long-polling-websockets-i)



### short-polling, long-polling, websockets и Sent event [&uarr;](#Other-tasks)

Очень часто встречается вопрос о том, как же работают уведомления/чаты в ВК или других высоконагруженных проектах?
Ведь такие уведомления приходят мгновенно и, если использовать обычный AJAX, то сервер достаточно быстро упадет.
Эта статья поможет прояснить, какие существуют способы реализации данного функционала.

#### Обычный HTTP запрос [&uarr;](#Other-tasks)
Для начала вспомним, как вообще идет HTTP запрос при обычной работе:

    1. Клиент посылает запрос на веб-страницу к серверу.
    2. Сервер формирует ответ.
    3. Сервер посылает ответ клиенту.

Как видим, общение между хостом и клиентом происходит в два этапа: запрос (client pull) и ответ (server push).
Клиент формирует HTTP запрос, в ответ на который сервер отдаёт данные. Учитывая такой алгоритм работы, возникает идея как можно
чаще опрашивать наш сервер, чтобы получать свежие данные и как можно быстрее отдавать клиенту информацию.

#### Периодические запросы (polling) [&uarr;](#Other-tasks)

Первое решение, которое приходит в голову для непрерывного получения событий с сервера – polling, т.е периодические запросы на
сервер: «эй, я тут, изменилось ли что-нибудь?». Например, раз в 10 секунд.

В ответ сервер во-первых помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате
содержится весь пакет событий, накопившихся к данному моменту. Для этого обычно используют подход, который называется AJAX.

#### Простые запросы (short-polling или просто AJAX) [&uarr;](#Other-tasks)

Алгоритм работы: запрос → ответ

    Отправляем запрос на сервер.
    Получаем немедленный ответ.
    Повторяем это действие каждые X секунд/минут/etc., чтобы получать актуальные данные для приложения (setInterval).

Такой подход подразумевает большое количество запросов на сервер. Это создаёт определённую нагрузку на сетевой трафик.
Ресурсы сервера нагружаются только во время запроса, но выгружаются как только был отдан ответ.

Плюсы:

    - Простота реализации. Причём, простота реализации тут достаточно условная. Клиентская часть – довольно проста, а вот сервер получает сразу большой поток запросов. Даже если клиент ушёл пить чай – его браузер каждые 10 секунд будет «долбить» сервер запросами. Готов ли сервер к такому?

Минусы:

    - Лишний входящий трафик на сервер. При каждом запросе браузер передает множество заголовков и в ответ получает, кроме данных, также заголовки. Для некоторых приложений трафик заголовков может в 10 и более раз превосходить трафик реальных данных.
    - Задержки между событием и уведомлением. Сервер отсылает данные не тогда, когда они появились, а когда прилетит новый запрос.
    - Серверу приходится хранить события пока клиент не заберет их или пока они не устареют. Это можно перекрыть, добавив кеширующий слой типа Varnish (потребуется больше памяти).

#### Длинные запросы (long-polling) [&uarr;](#Other-tasks)

Алгоритм работы: запрос → ожидание → ответ

    1. Отправляем запрос на сервер.
    2. Соединение не закрывается сервером, пока не появится сообщение.
    3. Когда сообщение появилось – сервер отвечает на запрос, пересылая данные.
    4. Браузер тут же делает новый запрос.

Улучшенный вариант предыдущего метода. Клиент отправляет запрос на сервер, сервер держит открытое соединение (thread) пока не
придут какие-нибудь данные или клиент не отключится самостоятельно. Как только данные пришли — отправляется ответ и соединение
закрывается, открывается следующее и так далее.

Если сравнивать этот подход с простыми запросами, то на его примере можно увидеть, что short-polling усиленно гоняет трафик,
но за те 3 секунды вы используете всего лишь 1,5 сек. процессорного времени — а это значит, что параллельно между запросами
и ответами вы можете запускать что-то ещё.

В случае с long-polling'ом, процессорное время будет использовано всё время, пока thread активен. И тут уже необходимо
рассчитывать серверные ресурсы.

Плюсы:

    - Минимальное количество запросов. Не нужно постоянно «долбать» сервер запросами.
    - Realtime-отдача данных.

Минусы:

    - Потребляет больше серверных ресурсов. Нагрузка существенно увеличивается, если входящие данные имеют большой размер.

#### Область применения [&uarr;](#Other-tasks)

Периодические запросы отлично работают в тех случаях, когда сообщения приходят редко.

При большом количестве частых сообщений (много пользователей — много диалогов) график приёма-отправки, приведённый выше,
превращается в «пилу». Каждое сообщение – это новый запрос, дополнительный трафик заголовков.

В этих случаях используются другие способы получения данных, подразумевающие непрерывное соединение с сервером.

#### WebSockets [&uarr;](#Other-tasks)

Алгоритм работы: клиент ↔ сервер

WebSockets — это бинарный дуплексный протокол, позволяющий клиенту и серверу общаться на равных. Типичная схема работы выглядит так:

    1. Отправляем запрос на сервер.
    2. Запрошенная страница выполняет JS, который открывает соединение с сервером.
    3. Сервер и клиент могут посылать друг другу сообщения, когда новая информация доступна (либо на сервере, либо на клиенте).

Создается TCP соединение с сервером и сохраняется открытым столько, сколько требуется. Сервер или клиент могут легко закрыть его.
При подключении происходит так называемое "рукопожатие" (handshaking), т.е. клиентом отсылаются специальные заголовки, которые
шифруются посредством base64. Если серверу всё понравилось, то он вернет заголовоковок Accept. Следует помнить, что клиентское
рукопожатие всегда будет иметь заголовок Origin, который будет отправлен на сервер, хотят они принимать клиентов с различных
источников или нет.

После установки соединения сервер и клиент могут посылать друг другу сообщения, когда новая информация доступна (либо на сервере,
либо на клиенте) - в обоих направлениях в любое время. Это очень эффективно, если приложение требует частого обмена данными в
обоих направлениях: можно применять для игр, чатов и всех тех приложений где вам нужны предельно точные события близкие к
реальному времени.

Плюсы по сравнению с polling:

    - Поднимается одно соединение
    - Предельно высокая временная точность событий
    - Управление сетевыми сбоями контролирует браузер

Минусы:

    - Не совместимый с HTTP протокол, нужен свой отдельный сервер, усложняется отладка.
    - Не поддерживается Opera-Mini и некоторыми другими старыми браузерами.

#### Server-Sent Events (SSE) [&uarr;](#Other-tasks)

Современный стандарт Server-Sent Events позволяет браузеру создавать специальный объект EventSource, который сам обеспечивает
соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных.

Клиент отправляет запрос на сервер, сервер в ответ отправляет следующий заголовок:

    Content-Type: text/event-stream

И не закрывает соединение. Вот и все — SSE работает! Чтобы отправить клиенту какие-то данные, сервер просто пишет в сокет
строку следующего формата:

    data: My message\n\n

Если необходимо отправить несколько строк данных, то формат будет следующим:

    data: {\n
    data: "msg": "hello world",\n
    data: "id": 12345\n
    data: }\n\n

SSE спроектирован иначе, чем WebSockets: WebSocket умеет слать сообщения в обе стороны (клиент ↔ сервер), Server-Sent-Events
только в одну (клиент ← сервер).

С другой стороны, SSE проще в реализации, работает по обычному протоколу HTTP и сразу поддерживает ряд возможностей, которые для
WebSockets ещё надо реализовать.

Поэтому в тех случаях, когда нужна преимущественно односторонняя передача данных от сервера к браузеру, они могут быть удачным
выбором.
