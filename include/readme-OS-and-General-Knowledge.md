# Readme

#### Список ссылок

- [Что такое Linux? Статья-шпаргалка](https://habr.com/ru/company/timeweb/blog/668344/)
- [Что такое /dev/null в Linux?](https://ravesli.com/dev-null-in-linux/)
- [Искусство командной строки](https://github.com/jlevy/the-art-of-command-line/blob/master/README-ru.md)
- [Основы Linux (обзор с практическим уклоном)](https://habr.com/ru/post/655275/)
- [Изучаем процессы в Linux. Управление процессами](https://ravesli.com/processes-v-linux/)
- []()
- []()


### Как работает ОС [&uarr;](#Readme)

Linux - это операционная система, которая основана на ядре Linux. Она представляет собой свободное программное обеспечение, 
которое может быть изменено и распространено пользователями в соответствии с лицензией GNU GPL. Linux был создан Линусом Торвальдсом 
в 1991 году и с тех пор стал популярным выбором для серверов, настольных компьютеров и множества других устройств.

Дистрибутив Linux — это операционная система, созданная на основе ядра Linux, которая включает в себя набор библиотек и утилит (пакетов), 
разработанных в рамках проекта GNU, а также систему управления пакетами (менеджер пакетов). В настоящее время существует более 500 различных 
дистрибутивов, разрабатываемых как при коммерческой поддержке (Red Hat / Fedora, SLED / OpenSUSE, Ubuntu и др.), так и исключительно усилиями 
добровольцев (Debian, Slackware, Gentoo, ArchLinux и др.).

Дистрибутивы делятся на несколько типов в зависимости от базового дистрибутива и системы управления пакетами. Вот несколько 
примеров наиболее популярных серверных дистрибутивов двух типов:

    RPM-based (используют формат пакетов .rpm)
    RedHat Enterprise Linux, CentOS, Fedora

    DEB-based (используют формат пакетов .deb)
    Debian, Ubuntu, Astra Linux


Плюсы Linux

    - Бесплатное использование. Использование большинства ОС Linux и большей части программ, основанных на ней, абсолютно бесплатно.
    - Открытый исходный код системы/программы. Благодаря доступу к исходному коду можно изучать его, изменять, распространять, а также публиковать изменения в соответствии с лицензией.
    - Актуальность и производительность. По сравнению с Windows Linux не устаревает со временем. То есть, чтобы восстановить первоначальную производительность, не нужно будет регулярно чистить или переустанавливать ОС, запускать дефрагментацию.
    - Безопасность. Linux поддерживает разные параметры безопасности, защищающие от вирусов, замедлений, вредоносных программ, сбоев. Это основная причина популярности ОС среди разработчиков. Конечно, Linux — не на 100% безопасная ОС, но менее уязвимая, чем другие.
    - Универсальность. Linux поддерживает практически все популярные языки программирования: Java, C/C++, Python, Ruby, C# и другие. Менеджер пакетов поможет установить и обновить целые и отдельные части компонентов ПО. Благодаря поддержке SSH можно быстро управлять серверами.
    - Дистрибутивы. Многие организации модифицировали ОС Linux, выпустив собственные дистрибутивы. Перечисляем наиболее популярные: Debian, Ubuntu, Linux Mint, Arch Linux, MX Linux, Fedora, Manjaro, CentOS. Linux Mint и Ubuntu подойдут начинающим пользователям, а Arch Linux, Fedora и Debian — опытным разработчикам. Дистрибутив можно собрать и самостоятельно.
    - Установка ПО из централизованного места — репозитория. Это место, где хранятся данные. Благодаря этому можно установить несколько программ одним щелчком мыши. Можно забыть о поиске кряков, серийных ключей и программ в интернете — с Linux это точно не понадобится.

В целом загрузку среднестатистического дистрибутива Linux можно разделить на пять стадий:

    1. Загрузчик.
    2. Запуск и первичная инициализация ядра.
    3. Обнаружение оборудования, загрузка драйверов и подключение файловых систем.
    4. Запуск системных служб (демонов).
    5. Старт графической или консольной пользовательской сессии.


### Терминал [&uarr;](#Readme)

#### bash

    Оболочка, или шелл (shell) — это программа, в нашем случае названная «bash», что является сокращением от Bourne Again Shell. 
    Оболочка принимает ваши команды и передаёт их операционной системе. 
    Для взаимодействия с системой используются терминалы, такие как gnome-terminal, eterm, nxterm и т. п.

    Bash - это интерпретатор команд. По сути, это обычная программа, которая запускается при старте сеанса оболочки. 
    Мы могли бы запускать не Bash, а скажем, интерпретатор python или ruby, и тогда нам пришлось бы выполнять методы этих языков вместо команд Bash для администрирования системы.

    Bash принимает команды от пользователя и передает их системному загрузчику, а также обеспечивает взаимодействие между командами, 
    обмен информацией и потоками ввода-вывода. Также оболочка предоставляет пользователю удобный интерфейс для работы с историей команд, поиска и замены, а также исправления ранее выполненных команд, а также автодополнение путей.

#### grep

    Утилита grep решает множество задач, в основном она используется для поиска строк, соответствующих строке в тексте или содержимому файлов. 
    Также она может находить по шаблону или регулярным выражениям. Команда в считанные секунды найдёт файл  с нужной строчкой, текст в файле или отфильтрует из вывода только пару нужных строк. А теперь давайте рассмотрим, как ей пользоваться.
     
    Синтаксис команды выглядит следующим образом:
    
    $ grep [опции] шаблон [имя файла...]
    
    Или:
    
    $ команда | grep [опции] шаблон

    Опции - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода, например количество строк или режим инверсии.
    Шаблон - это любая строка или регулярное выражение, по которому будет вестись поиск
    Файл и команда - это то место, где будет вестись поиск. Как вы увидите дальше, grep позволяет искать в нескольких файлах и даже в каталоге, используя рекурсивный режим.

#### alias

    Используйте alias, чтобы поименовать часто используемые команды. Например, alias ll='ls -latr' создаст новое сокращение ll

#### xargs

    Не забывайте использовать xargs (или parallel). Это очень мощная штука. 
    Обратите внимание, что вы можете контролировать количество команд на каждую строку (-L), а также параллельность (-P). Если вы не уверены, что делаете что-то правильно, начните с xargs echo. Еще -I{} – полезная штука. Примеры:

    Возможность объединения нескольких команд Linux в терминале и использования их в качестве конвейера, когда каждая следующая команда получает вывод предыдущей - очень мощный и гибкий инструмент. Но команды можно объединять не только так. 
    С помощью утилиты xargs вывод предыдущей команды можно передать в аргументы следующей.

    Синтаксис команды немного запутанный, но в нём можно разобраться:
    
    $ первая_команда | xargs опции вторая_команда аргументы
    
    Сначала выполняется любая первая команда и весь её вывод по туннелю передается в xargs. Затем этот вывод разбивается на строки и для каждой строки вызывается вторая команда, а полученная строка передаётся ей в аргументах.

      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname

#### cd

    Перейти в домашнюю директорию можно с помощью cd. Для указания пути к файлам из домашней директории можно воспользоваться префиксом ~ (например, ~/.bashrc). В sh скриптах для обращения к домашней директории можно использовать переменную $HOME.
    Для того, чтобы перейти к предыдущей рабочей директории, используйте cd -

#### netstat

    Узнайте, какие процессы слушают порты через netstat -lntp или ss -plat (для TCP; добавьте -u для UDP).

#### history

    `Для просмотра последних команд используйте history. Повторить команду: !n (где n - порядковый номер истории). `

#### ssh

    Синтаксис команды выглядит следующим образом:

    $ ssh [опции] имя пользователя@сервер [команда]
    Чтобы просто подключиться к серверу по SSH:
    
    ssh user@host

    Мы привыкли подключаться к удаленному серверу, а уже потом выполнять нужные команды, 
    но на самом деле утилита ssh позволяет сразу выполнить нужную команду без открытия терминала удаленной машины. Например:
    
    ssh user@host ls

#### Как найти файл с определенной подстрокой в директории со вложенностями? [&uarr;](#devmap)

    использовать find либо же grep




### Управление процессами [&uarr;](#Readme)

#### Типы процессов

`Процесс` — это экземпляр запущенной программы. Всякий раз, когда в терминале выполняется какая-нибудь команда (например, команда pwd), 
система создает/запускает новый процесс.

В `Linux` существует три основных типа процессов:

- `Процессы переднего плана` (или «интерактивные процессы») — инициализируются и управляются с помощью терминального сеанса. 
Другими словами, необходимым условием для запуска таких процессов является наличие пользователя, подключенного к системе; 
они не запускаются автоматически как часть системных функций/служб. Когда команда/процесс выполняется на переднем плане, 
то они полностью занимают запустивший их терминал. Вы не сможете использовать другие команды, т.к. приглашение оболочки будет 
недоступно, пока данный процесс выполняется на переднем плане.

- `Фоновые процессы` (или «автоматические процессы») — это процессы, не подключенные к терминалу; они не ожидают пользовательского ввода данных. 
Таким образом, другие процессы могут выполняться параллельно с процессом, запущенным в фоновом режиме, поскольку им не нужно ждать его завершения.

- `Демоны` (англ. «daemons») — это особый тип фоновых процессов, которые запускаются при старте системы и продолжают работать в виде службы; 
они не умирают. Такие процессы запускаются как системные задачи (службы). Однако при этом они могут управляться пользователем через 
init-процесс (о котором мы поговорим чуть позже). Например, к демонам относится служба электронных сообщений sendmail и sshd 
(служба, принимающая от клиентов запросы на соединения по протоколу ssh). За исключением процесса init и некоторых других, процессы демонов 
обычно имеют окончание d в своем имени.


#### Как Linux идентифицирует процессы?

Поскольку Linux является многопользовательской системой, разные пользователи могут запускать различные программы, при этом 
каждый запущенный экземпляр программы должен быть однозначно идентифицирован ядром.

Процессы запущенной программы имеют уникальный пятизначный номер — `PID` (сокр. от «Process IDentificator» — «идентификатор процесса»), 
а также PPID (сокр. от «Parent Process IDentificator» — «идентификатор родительского процесса»). В связи с этим процессы дополнительно 
разделяют на две группы:

- `Родительские процессы` — это процессы, которые во время своего выполнения создают другие процессы.

- `Дочерние процессы` — эти процессы, создаваемые другими процессами во время своего выполнения.

Прародителем всех процессов в системе является процесс `init` (от англ. «initialization») — первая программа, которая выполняется 
при загрузке Linux и управляет всеми другими процессами в системе. init запускается самим ядром и всегда имеет PID = 1, поэтому 
у него в принципе нет родительского процесса.

    Примечание: В любой момент времени в системе не существует двух процессов с одинаковым PID. Вновь создаваемому процессу может 
    быть назначен ранее использованный свободный PID.


#### Состояния процесса в Linux

`Выполнение` — процесс либо запущен (текущий процесс в системе), либо готов к запуску (ожидает передачи на выполнение процессору).

`Ожидание` — процесс ожидает наступления некоторого события (пользовательского ввода, сигнала от другого процесса и т.п.) или 
выделения системных ресурсов. Кроме того, ядро также различает два типа ожидающих процессов:

    - прерываемые ожидающие процессы — могут быть прерваны сигналами;
    - непрерываемые ожидающие процессы — процессы ожидают непосредственно на аппаратном уровне и не могут быть прерваны каким-либо событием/сигналом.

`Завершен` — процесс был остановлен, как правило, путем получения сигнала штатного завершения работы exit().

`Зомби` — иногда, когда родительский процесс убивается до завершения дочернего процесса, дочерние процессы становятся «осиротевшими», 
при этом в качестве нового родителя (с соответствующим изменением PPID) им назначается процесс init. Убитые процессы, но при этом все 
еще отображающиеся в таблице процессов, называются процессами зомби (они мертвы и не используются).


#### Как получить идентификатор (PID) процесса

Для отображения идентификатора нужного вам процесса можно использовать команду pidof, например:

    $ pidof init
    $ pidof bash
    $ pidof systemd


#### Отслеживание активных процессов

Существует несколько различных инструментов для просмотра/перечисления запущенных в системе процессов. Двумя традиционными 
и хорошо известными из них являются команды ps и top.

##### Команда ps

Отображает информацию об активных процессах в системе, как показано на следующем скриншоте:

    $ ps
    $ ps -e | head #(head – фильтр, отображающий только первые 10 строк вывода команды "ps -e")

Для получения дополнительной информации о процессах, запущенных текущим пользователем, применяется опция -f:

    $ ps -f

Столбцы, присутствующие в выводе команды ps, имеют следующие значения:

    UID — идентификатор пользователя, которому принадлежит процесс (тот, от чьего имени происходит выполнение).
    
    PID — идентификатор процесса.
    
    PPID — идентификатор родительского процесса.
    
    C — загрузка CPU процессом.
    
    STIME — время начала выполнения процесса.
    
    TTY — тип терминала, связанного с процессом.
    
    TIME — количество процессорного времени, потраченного на выполнение процесса.
    
    CMD — команда, запустившая этот процесс.


##### Команда top

Команда top отображает информацию о запущенных процессах в режиме реального времени:

    $ top

Столбцы, присутствующие в выводе команды top, имеют следующие значения:

    PID — идентификатор процесса.
    
    USER — пользователь, которому принадлежит процесс.
    
    PR — приоритет процесса на уровне ядра.
    
    NI — приоритет выполнения процесса от -20 до 19.
    
    VIRT — общий объем (в килобайтах) виртуальной памяти (физическая память самого процесса; загруженные с диска файлы библиотек; память, совместно используемая с другими процессами и т.п.), используемой задачей в данный момент.
    
    RES — текущий объем (в килобайтах) физической памяти процесса.
    
    SHR — объем совместно используемой с другими процессами памяти.
    
    S (сокр. от «STATUS») — состояние процесса:
    
        S (сокр. от «Sleeping») — прерываемое ожидание. Процесс ждет наступления события.
    
        I (сокр. от «Idle») — процесс бездействует.
        
        R (сокр. от «Running») — процесс выполняется (или поставлен в очередь на выполнение).
        
        Z (сокр. от «Zombie») — зомби-процесс.
    
    %CPU — процент используемых ресурсов процессора.
    
    %MEM — процент используемой памяти.
    
    TIME+ — количество процессорного времени, затраченного на выполнение процесса.
    
    COMMAND — имя процесса (команды).



### Потоки и парралелизм [&uarr;](#Readme)



### Управление памятью [&uarr;](#Readme)



### Межпроцессорное взаимодействие [&uarr;](#Readme)



### Управление I/O [&uarr;](#Readme)



### Основы POSIX [&uarr;](#Readme)



### Концепция построения сети [&uarr;](#Readme)


Основное назначение компьютерных сетей - совместное использование ресурсов и осуществление интерактивной связи как внутри 
одной фирмы, так и за ее пределами. 

Ресурсы (resources) - это данные, приложения и периферийные устройства, такие, как внешний дисковод, принтер, мышь, модем 
или джойстик. Понятие интерактивной связи компьютеров подразумевает обмен сообщениями в реальном режиме времени. 

До появления компьютерных сетей каждый пользователь должен был иметь свой принтер, плоттер и другие 
периферийные устройства. Чтобы совместно использовать принтер, существовал единственный способ - пересесть за компьютер, подключенный 
к этому принтеру. Сети позволяют целому ряду пользователей одновременно `владеть` данными на носителях прямого доступа и 
периферийными устройствами. Если нескольким пользователям надо распечатать документ, все они могут обратиться к сетевому принтеру. 

Самая простая сеть (network) состоит как минимум из двух компьютеров, соединенных друг с другом кабелем. Это позволяет им использовать 
данные совместно. Все сети (независимо от сложности) основываются именно на этом простом принципе. Рождение компьютерных сетей было 
вызвано практической потребностью - иметь возможность для совместного использования данных. Персональный компьютер - прекрасный 
инструмент для создания документа, подготовки таблиц, графических данных и других видов информации, но при этом Вы не можете быстро 
поделиться своей информацией с другими. Когда не было сетей, приходилось распечатывать каждый документ, чтобы другие пользователи 
могли работать с ним, или в лучшем случае - копировать информацию на дискеты. Одновременная обработка документа несколькими 
пользователями исключалась. Подобная схема работы называется работой в автономной среде. 

Сетью называется группа соединенных компьютеров 
и других устройств. А концепция соединенных и совместно использующих ресурсы компьютеров носит название сетевого взаимодействия. 
Компьютеры, входящие в сеть, могут совместно использовать: 

- данные; 
- принтеры; 
- факсимильные аппараты; 
- модемы; 
- другие устройства.

