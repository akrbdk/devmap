#### ALGORITMS

### определить сложность алгоритма

```php
O(n) — линейная сложность

Такой сложностью обладает, например, алгоритм поиска наибольшего элемента в не отсортированном массиве. Нам придётся 
пройтись по всем n элементам массива, чтобы понять, какой из них максимальный.

O(log n) — логарифмическая сложность

Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное 
значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину 
массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить 
пополам, в итоге проверим log n элементов.

O(n2) — квадратичная сложность

Такую сложность имеет, например, алгоритм сортировки вставками. В канонической реализации он представляет из себя два 
вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже 
отсортированной части. Таким образом, количество операций будет зависеть от размера массива как n * n, т. е. n2.

Бывают и другие оценки по сложности, но все они основаны на том же принципе.

Также случается, что время работы алгоритма вообще не зависит от размера входных данных. Тогда сложность обозначают 
как O(1). Например, для определения значения третьего элемента массива не нужно ни запоминать элементы, ни проходить 
по ним сколько-то раз. Всегда нужно просто дождаться в потоке входных данных третий элемент и это будет результатом, 
на вычисление которого для любого количества данных нужно одно и то же время.
```

### Нахождение факториала

```php
function factorial($n): float|int
{
    return $n < 2 ? 1 : $n * factorial($n - 1);
}

echo factorial(5); //120
```

### Написать функцию для возведения числа в заданную степень с помощью рекурсии.

```php
function degree($n, $degree){
	return $degree < 2 ? $n : $n * degree($n, $degree - 1);
}

echo degree(5, 3); //125
```

### Вычисление последовательности Фибоначчи

```php

// Рекурсивный алгоритм вычисления последовательности Фибоначи
function fib1($n)
{
    return $n < 3 ? 1 : fib1($n - 1) + fib1($n - 2);
}

function fib2($n, $c = 2, $n2 = 0, $n1 = 1)
{
    return $c < $n ? fib2($n, $c + 1, $n1, $n1 + $n2) : $n1 + $n2;
}

// Итеративный алгоритм вычисления последовательности Фибоначчи
function F($n){
  $i=1; $r=1; $l=1; $s=1;
  while($i++<$n){
    $s=$l+$r;
    $l=$r;
    $r=$s;
  }
  return $s;
}

// Рекурсивный алгоритм Фибоначчи
// с использованием подхода восходящего динамического программирования
function F_recursive($n, $K){
  if($n<=1) {
    return 1;
  } elseif ($K[$n] == 0) {
    $K[$n]=F_recursive($n-1,$K) + F_recursive($n-2,$K);
  }
  return $K[$n];
}
function F($n){
  $K=array_fill(0,$n+1,0);
  return F_recursive($n,$K);
}

// Рекурсивный алгоритм Фибоначчи
// с применением Объектно-Ориентированного Подхода
class Fibonachi {
  private $K;
  private function F_recursive($n){
  if($n<=1) {
    return 1;
  } elseif ($this->K[$n] == 0) {
    $this->K[$n]=$this->F_recursive($n-1,$this->K) + $this->F_recursive($n-2,$this->K);
  }
  return $this->K[$n];
  }
  // Интерфейс класса
  public function getNumberByIndex($n){
    $this->K=array_fill(0,$n+1,0);
    return $this->F_recursive($n);
  }
}
function F($n){
  $Fibonachi = new Fibonachi();
  return $Fibonachi->getNumberByIndex($n);
}


```

### Вычисление перестановок Ханойских башен

[Реализация Ханойской башни на PHP](https://progtips.ru/php/rekursivnye-algoritmy-na-php-chast-2-polza-rekursii.html)

```php
// Пример рекурсивного решения задачи о Ханойских башнях
 
  function towers($n, $a, $c, $b){
    if($n==1){
      echo $a,"->",$c," ";
    } else {
      towers($n-1,$a,$b,$c);
      echo $a,"->",$c," ";
      towers($n-1,$b,$c,$a);
    }
  }

//ИЛИ ВОТ ТАК

function tower_of_hanoi($numbers, $start, $auxiliary, $end){
    if($numbers == 1){
        echo 'Move disk 1 from rod {' . $start . '} to rod {' . $end . '}' . "\n";
    } else {
    	tower_of_hanoi($numbers - 1, $start, $end, $auxiliary);
    	echo 'Move disk {' . $numbers . '} from rod {' . $start . '} to rod {' . $end . '}' . "\n";
    	tower_of_hanoi($numbers - 1, $auxiliary, $start, $end);
    }
} 

tower_of_hanoi(3, 'A', 'B', 'C');
```

```

### Рекурсивный обход дерева

```php

$tree = mkdir('/', [
  mkdir('etc', [
    mkfile('bashrc'),
    mkfile('consul.cfg'),
  ]),
  mkfile('hexletrc'),
  mkdir('bin', [
    mkfile('ls'),
    mkfile('cat'),
  ]),
]);

function dfs($tree)
{
  // Распечатываем содержимое узла
  echo getName($tree) . "\n";
  // Если это файл, то возвращаем управление
  if (isFile($tree)) {
      return;
  }

  // Получаем детей
  $children = getChildren($tree);

  // Применяем функцию dfs ко всем дочерним элементам
  // Множество рекурсивных вызовов в рамках одного вызова функции
  // называется древовидной рекурсией
  array_map(fn($child) => dfs($child), $children);
}

dfs($tree);
// => /
// => etc
// => bashrc
// => consul.cfg
// => hexletrc
// => bin
// => ls
// => cat
```

Вопросы по массивам:

- Найти второй минимальный элемент массива

```php
Хранить два текущих значения `Max` и `Second`
На каждом шаге:
  Если очередное значение A[i] >= Max:
     Second = Max
     Max = A[i]
  иначе если A[i] > Second:
     Second = A[i]
```

- Поиск максимального элемента в массиве

```php
Хранить `Max`
На каждом шаге:
  Если очередное значение A[i] >= Max:
     Max = A[i]
```

- Объединить два отсортированных массива

```php
$arr1 = [0 => "max",1 => "min",2 => "med"]; 
$arr2 = [0 => "max",1 => "min",2 => "other",3 =>"med"];

$finalArr = (array_unique(array_merge($arr1, $arr2)));
```

Объявлены две числовые переменные a и b. Необходимо сделать так, чтобы без объявления других переменных в результате
работы алгоритма значения переменных поменялись местами. (Например, если изначально a = 3, b = 5, то в результате
алгоритма стало a = 5, b = 3). Применять можно только операции присваивания и арифметические операции с числами и
значениями переменных.

```php
a+=b;
b=a-b;
a-=b;
```

Дано натуральное число n. С помощью рекурсивной функции и не используя циклы, выведите все числа от 1 до n.

```php
function my_function($n) {
  return $n <= 1? 1 : my_function($n - 1) . ' ' . $n;
}
echo my_function(11); //1 2 3 4 5 6 7 8 9 10 11
```

Дана строка (возможно, пустая), состоящая из букв A-Z: AAAABBBCCXYZDDDDEEEFFFAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBB
Нужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3A6B28
И сгенерирует ошибку, если на вход пришла невалидная строка.
Пояснения: Если символ встречается 1 раз, он остается без изменений; Если символ повторяется более 1 раза, к нему
добавляется количество повторений.

```php
def convert(s: str) -> str:
  result: List[str] = []
  last_sym = None  # последний символ, что мы видели
  count = 0  # и сколько мы его видели

  # мы будем идти по строке и записывать в result при смене символа
  for sym in (list(s) + [None]):  # последний None искусственно триггерит посленюю смену символа

      if last_sym and sym != last_sym:  # если случилась смена символа

          if count == 1:
              result.append(last_sym)
          else:
              result.append(last_sym + str(count))

      	  # начнаем запоминать новый символ
          count = 1
          last_sym = sym

      else:  # символ просто повторился
          count += 1  # ну ок, запомнили что символ видели на 1 раз больше

  return ''.join(result)
```

Сгруппировать слова по "общим буквам".
Sample Input ["eat", "tea", "tan", "ate", "nat", "bat"]
Sample Output [ ["ate", "eat", "tea"], ["nat", "tan"], ["bat"] ]

```php
function sortString($str){
    // разбиваем строку на массив букв
    $letters = str_split(strtolower($str));
    // сортируем массив букв 
    sort($letters);
    // соединяем массив букв в слово и возвращаем его
    return implode($letters);
}

//входные данные
$array = array('rfv', 'vfr', 'abc', 'bac', 'dbatre', 'qwer', 'cba', 'terbda');

// будем проходиться по массиву используся функцию array_reduce(),
// с callback-функцией, которая возвращает заново сформированный массив
$grouppedArray = array_reduce($array, function($accumulator, $item) {
    // пользуемся выше созданной функцией которая сортируем по алфавиту слово
    $itemSorted = sortString($item);
    // записываем в возвращаемый массив новое значение 
    // с ключом вида отсортированного ранее слова,
    // или добавляем его, если существует такой массив
    $accumulator[$itemSorted][] = $item;
    // возвращаем общий массив для следующей итерации
    return $accumulator;
});
```
