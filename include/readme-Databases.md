# Readme



SQL
- DDL, DML, DQL
- Создание и удаление базы данных, таблицы
- Добавление, обновление и удаление записи
- Схема (SCHEMA)
- Представления (VIEWS)
- WHERE
- LIMIT, OFFSET
- ORDER BY
- GROUP BY
- JOIN
- Подзапросы






1) ОБЩЕЕ
-  транзакции
-  блокировочные и версионные СУБД
-  индексы (зачем нужны, плюсы и минусы)
-  репликация
-  шардинг (партиционирование)
-  типичные bottle necks

2) PostgreSql
pgBouncer — что это и зачем нужно
системы репликации
PgQ (другие очереди)
синхронные и асинхронные операции

3) MYSQL
-  конфигурации БД, репликации, EXPLAIN
-  Проектирование БД. Порядок полей в таблице. Нормальные формы.
-  Чем отличается WHERE от HAVING
-  Основные отличия MyISAM и InnoDB. Преимущества и недостатки.
-  Left Join, Right Join, Inner Join, Outer Join
-  Какие уровни изоляции транзакций вы знаете? В каких случаях стоит использовать составной индекс, в каких - нет.
-  Уязвимости бд, варианты взлома, шифрование паролей - Пару вопросов про безопасность, как защититься от CSRF, от SQL-Injection. Как вы сохраняете пароли в своих проектах.
-  В чем заключается оптимизация БД, и в частности MySQL.

   highload проекты









## ORM [&uarr;](#Readme)



### Doctrine [&uarr;](#Readme)


Doctrine — объектно-реляционный проектор (ORM) для PHP 7.1+, который базируется на слое абстракции доступа к БД (DBAL).
Одной из ключевых возможностей Doctrine является запись запросов к БД на собственном объектно-ориентированном диалекте
SQL, называемом DQL (Doctrine Query Language) и базирующемся на идеях HQL (Hibernate Query Language).

Doctrine ORM применяется во фреймворках Laravel, Yii, Symfony.

Doctrine ORM предоставляет разработчику удобные средства выборки данных. Это и мощный DQL для работы в
объектно-ориентированном ключе, и удобный Query Builder, простой и понятный в использовании. Они покрывают большую часть
потребностей, но иногда возникает необходимость использовать SQL запросы, оптимизированные или специфичные для
конкретной СУБД. Для работы с результатами запросов в коде важно понимание того, как работает маппинг в Doctrine.

В основе Doctrine ORM лежит паттерн Data Mapper, изолирующий реляционное представление от объектного, и конвертирующий
данные между ними. Одним из ключевых компонентов этого процесса является объект ResultSetMapping, с помощью которого
описывается, как именно преобразовывать результаты запроса из реляционной модели в объектную. Doctrine всегда использует
ResultSetMapping для представления результатов запроса, но обычно этот объект создается на основе аннотаций или yaml,
xml конфигов, остается скрыт от глаз разработчика, потому о его возможностях знают далеко не все.

В Doctrine есть два QueryBuilder — SQL и ORM (DQL). ResultSetMapping предназначен для работы с SQL-запросами, а метод
createQueryBuilder EntityManager'a вернет Вам ORM QueryBuilder. В последнем случае я не вижу необходимости использовать
ручной ResultSetMapping, т.к. запрос Вы составляете уже в терминах описанных сущностей, используя DQL. В первом же
случае, при использовании SQL QueryBuilder, поля в выборке переименовываться не будут.


### ACID [&uarr;](#Readme)



### Raise Condition [&uarr;](#Readme)


Состояние гонки (англ. race condition), также конкуренция[1] — ошибка проектирования многопоточной системы или
приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Термин состояние гонки относится к инженерному жаргону и появился вследствие неаккуратного дословного перевода
английского эквивалента. В более строгой академической среде принято использовать термин неопределённость параллелизма.

Состояние гонки — «плавающая» ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и «пропадающая» при попытке
её локализовать.

Возможные последствия

    утечки памяти
    ошибки сегментирования
    порча данных
    уязвимости
    взаимные блокировки
    утечки других ресурсов, например файловых дескрипторов

Как с этим бороться:

В первую очередь это конечно же архитектурная проблема, если правильно спроектировать веб-приложение, можно избежать
подобных гонок.

Обычно, применяют следующие методы борьбы с атакой:

    Используют блокировки.

    Операция блокирует в СУБД обращения к заблокированному объекту, пока его не разблокируют. Другие стоят и ждут в сторонке. Необходимо правильно работать с блокировками, не блокировать ничего лишнего.


    Рулят изоляциями транзакций.

    Упорядоченные транзакции (serializable) — гарантируют, что транзакции будут выполнены строго последовательно, однако, это может сказаться на производительности.


    Используют мьютексные семафоры (хе-хе).

    Берут какую-нибудь штуку (например etcd). В момент вызова функций создают запись с ключом, если не получилось создать запись, значит она уже есть и тогда запрос прерывается. По окончании обработки запроса запись удаляется.


### Транзакции [&uarr;](#Readme)



### Проблема-N+1 [&uarr;](#Readme)



### Нормализация [&uarr;](#Readme)



### Failure Modes [&uarr;](#Readme)



### Профилирование [&uarr;](#Readme)



### Индексы [&uarr;](#Readme)



### Репликация [&uarr;](#Readme)



### Шардирование [&uarr;](#Readme)



### Теорема-CAP [&uarr;](#Readme)



### MongoDB [&uarr;](#Readme)



### CouchDB [&uarr;](#Readme)



### InfluxDB [&uarr;](#Readme)



### TimeScale [&uarr;](#Readme)



### Firebase [&uarr;](#Readme)



### RethinkDB [&uarr;](#Readme)



### Cassandra [&uarr;](#Readme)



### HBase [&uarr;](#Readme)



### Redis [&uarr;](#Readme)



### DynamoDB [&uarr;](#Readme)



### Neo4i [&uarr;](#Readme)



### PostgreSQL [&uarr;](#Readme)



### MySQL [&uarr;](#Readme)



### MariaDB [&uarr;](#Readme)



### MS SQL [&uarr;](#Readme)



### Oracle [&uarr;](#Readme)




