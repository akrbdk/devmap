
## Наблюдатель (Observer)

Паттерн Observer относится к поведенческим паттернам уровня объекта.

Паттерн Observer определяет зависимость "один-ко-многим" между объектами так, что при изменении состояния одного объекта все зависящие от него объекты уведомляются об этом и обновляются автоматически.

Основные участиники паттерна это Издатели (Subject) и Подписчики (Observer). 

Имеется два способа получения уведомлений от издателя:

1. Метод вытягивания: После получения уведомления от издателя, подписчик должен пойти к издателю и забрать (вытянуть) данные самостоятельно.  
2. Метод проталкивания: Издатель не уведомляет подписчика об обновлениях данных, а самостоятельно доставляет (проталкивает) данные подписчику.


## Примеры из жизни

    Система очереди сообщений наблюдает за очередями, чтобы отображать прогресс в GUI

## Примечание

PHP предоставляет два стандартных интерфейса, которые могут помочь реализовать этот шаблон: SplObserver и SplSubject.

## Пример

Требуется для реализации:

1. Абстрактный класс Subject, определяющий интерфейс Издателя;
2. Класс ConcreteSubject, реализует интерфейс Subject;
3. Абстрактный класс Observer, определяющий общий функционал Подписчиков;
4. Класс ConcreteObserver, реализует Подписчика;

## Применимость

### Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.

    Описанная проблема может возникнуть при разработке библиотек пользовательского интерфейса, когда вам надо дать возможность сторонним классам реагировать на клики по кнопкам.

    Паттерн Наблюдатель позволяет любому объекту с интерфейсом подписчика зарегистрироваться на получение оповещений о событиях, происходящих в объектах-издателях.

### Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

    Издатели ведут динамические списки. Все наблюдатели могут подписываться или отписываться от получения оповещений прямо во время выполнения программы.


## Шаги реализации

1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет издателем. Зависимые части станут подписчиками.

2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.

3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.

4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.

Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.

5. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.

6. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.

Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.

7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

## Преимущества и недостатки

    + Издатели не зависят от конкретных классов подписчиков и наоборот.
    + Вы можете подписывать и отписывать получателей на лету.
    + Реализует принцип открытости/закрытости.

    - Подписчики оповещаются в случайном порядке.

## Отношения с другими паттернами

1. `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей запросов с их получателями:
    
    Цепочка обязанностей передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    Команда устанавливает косвенную одностороннюю связь от отправителей к получателям.
    Посредник убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    Наблюдатель передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.

2. Разница между `Посредником` и `Наблюдателем` не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.

    Цель Посредника — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель Наблюдателя — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

    Довольно популярна реализация Посредника при помощи Наблюдателя. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.

    Но Посредник имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать Наблюдателя, но всё же останется Посредником.

    Напротив, в случае реализации посредника с помощью Наблюдателя представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети Наблюдателей, не имея центрального объекта-Посредника.



