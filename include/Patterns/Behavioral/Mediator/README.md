## Посредник (Mediator)

Паттерн Mediator относится к поведенческим паттернам уровня объекта.

Паттерн Mediator предоставляет объект-посредник, скрывающий способ взаимодействия множества других объектов-коллег.
Mediator делает систему слабо связанной, избавляя объекты от необходимости ссылаться друг на друга, что позволяет
изменять взаимодействие между ними независимо.

## Пример

Например, у нас есть посредник между заводом производства хлебобулочных изделий, фермером и магазином сбыта. Посредник
избавляет фермера от взаимодействия с заводом, который использует его сырье, а завод от взаимодействия с магазином, в
который поступает продукция для сбыта.

Требуется для реализации:

1. Интерфейс Mediator - посредник описывающий организацию процесса по обмену информацией между объектами типа Colleague;
2. Класс ConcreteMediator, реализующий интерфейс Mediator;
3. Базовый абстрактный класс Colleague - коллега описывающий организацию процесса взаимодействия объектов-коллег с
   объектом типа Mediator;
4. Класс ConcreteColleague, реализующий интерфейс Colleague. Каждый объект-коллега знает только об объекте-медиаторе.
   Все объекты-коллеги обмениваются информацией только через посредника.

## Применимость

### Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.

    Посредник позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.

### Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.

    После применения паттерна компоненты теряют прежние связи с другими компонентами, а всё их общение происходит косвенно, через объект-посредник.

### Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.

    Если раньше изменение отношений в одном компоненте могли повлечь за собой лавину изменений во всех остальных компонентах, то теперь вам достаточно создать подкласс посредника и поменять в нём связи между компонентами.

## Шаги реализации

1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например,
   чтобы повторно использовать их код в другой программе.

Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами. В простейшем случае
достаточно одного метода для получения оповещений от компонентов.

2. Этот интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач. В этом случае
   всё, что нужно сделать — это создать новый класс конкретного посредника.

3. Реализуйте этот интерфейс в классе конкретного посредника. Поместите в него поля, которые будут содержать ссылки на
   все объекты компонентов.

4. Вы можете пойти дальше и переместить код создания компонентов в класс посредника, после чего он может напоминать
   фабрику или фасад.

5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобнее всего установить, подавая
   посредника в параметры конструктора компонентов.

6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов. С
   противоположной стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение от
   компонента.

## Преимущества и недостатки

    + Устраняет зависимости между компонентами, позволяя повторно их использовать.
    + Упрощает взаимодействие между компонентами.
    + Централизует управление в одном месте.

    - Посредник может сильно раздуться.

## Отношения с другими паттернами

1. `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей
   запросов с их получателями:
   Цепочка обязанностей передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из
   них обработает запрос.
   Команда устанавливает косвенную одностороннюю связь от отправителей к получателям.
   Посредник убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
   Наблюдатель передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться
   или отписываться от таких оповещений.

2. `Посредник` и `Фасад` похожи тем, что пытаются организовать работу множества существующих классов.
   Фасад создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема
   не знает о существовании Фасада. Классы подсистемы общаются друг с другом напрямую.
   Посредник централизует общение между компонентами системы. Компоненты системы знают только о существовании
   Посредника, у них нет прямого доступа к другим компонентам.

3. Разница между `Посредником` и `Наблюдателем` не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда
   могут работать вместе.

Цель Посредника — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от
самого посредника. С другой стороны, цель Наблюдателя — обеспечить динамическую одностороннюю связь, в которой одни
объекты косвенно зависят от других.

Довольно популярна реализация Посредника при помощи Наблюдателя. При этом объект посредника будет выступать издателем, а
все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В
этом случае трудно понять, чем же отличаются оба паттерна.

Но Посредник имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд
ли будет напоминать Наблюдателя, но всё же останется Посредником.

    Напротив, в случае реализации посредника с помощью Наблюдателя представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети Наблюдателей, не имея центрального объекта-Посредника.



