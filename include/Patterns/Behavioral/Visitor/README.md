## Посетитель (Visitor)

Паттерн Visitor относится к поведенческим паттернам уровня объекта.

Паттерн Visitor позволяет обойти набор элементов (объектов) с разнородными интерфейсами, а также позволяет добавить
новый метод в класс объекта, при этом, не изменяя сам класс этого объекта.

Шаблон «Посетитель» выполняет операции над объектами других классов. Главной целью является сохранение разделения
направленности задач отдельных классов. При этом классы обязаны определить специальный контракт, чтобы позволить
использовать их Посетителям (метод «принять роль» Role::accept в примере).

Контракт, как правило, это абстрактный класс, но вы можете использовать чистый интерфейс. В этом случае, каждый
посетитель должен сам выбирать, какой метод ссылается на посетителя.

## Пример

Требуется для реализации:

1. Абстрактный класс Visitor, описывающий интерфейс визитера;
2. Класс ConcreteVisitor, реализующий конкретного визитера. Реализует методы для обхода конкретного элемента;
3. Класс ObjectStructure, реализующий структуру(коллекцию), в которой хранятся элементы для обхода;
4. Абстрактный класс Element, реализующий интерфейс элементов структуры;
5. Класс ElementA, реализующий элемент структуры;
6. Класс ElementB, реализующий элемент структуры.

## Применимость

### Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.

Посетитель позволяет применять одну и ту же операцию к объектам различных классов.

### Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.

Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один
класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое
приложение включить только нужные операции.

### Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.

## Шаги реализации

1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует в
   программе.

2. Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия
   посетителей в базовом классе иерархии элементов.

3. Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя, в
   котором тип параметра совпадает с текущим классом элемента.

4. Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать обо
   всех классах элементов.

5. Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми
   типами элементов, реализовав все методы интерфейса посетителей.

Вы можете столкнуться с ситуацией, когда посетителю нужен будет доступ к приватным полям элементов. В этом случае вы
можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию элементов, либо сделать класс посетителя вложенным в
класс элемента, если вам повезло писать на языке, который поддерживает вложенность классов.

6. Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.

## Преимущества и недостатки

    + Упрощает добавление операций, работающих со сложными структурами объектов.
    + Объединяет родственные операции в одном классе.
    + Посетитель может накапливать состояние при обходе структуры элементов.

    - Паттерн не оправдан, если иерархия элементов часто меняется.
    - Может привести к нарушению инкапсуляции элементов.

## Отношения с другими паттернами

1. `Посетитель` можно рассматривать как расширенный аналог `Команды`, который способен работать сразу с несколькими
   видами получателей.

2. Вы можете выполнить какое-то действие над всем деревом `Компоновщика` при помощи `Посетителя`.

3. `Посетитель` можно использовать совместно с `Итератором`. `Итератор` будет отвечать за обход структуры данных, а
   `Посетитель` — за выполнение действий над каждым её компонентом.

