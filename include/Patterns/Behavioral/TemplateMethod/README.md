## Шаблонный метод (Template Method)

Паттерн Template Method относится к поведенческим паттернам уровня класса.

Паттерн Template Method формирует структуру алгоритма и позволяет в производных классах реализовать, перекрыть или
переопределить определенные шаги алгоритма, не изменяя структуру алгоритма в целом.

Проектировщик решает, какие шаги алгоритма являются неизменными, а какие изменяемыми. Абстрактный базовый класс
реализует стандартные неизменяемые шаги алгоритма и может предоставлять реализацию по умолчанию для изменяемых шагов.
Изменяемые шаги могут предоставляться клиентом компонента в конкретных производных классах.

Возможно, вы сталкивались с этим уже много раз. Идея состоит в том, чтобы позволить наследникам абстрактного шаблона
переопределить поведение алгоритмов родителя.

Как в «Голливудском принципе»: «Не звоните нам, мы сами вам позвоним». Этот класс не вызывается подклассами, но
наоборот: подклассы вызываются родителем. Как? С помощью метода в родительской абстракции, конечно.

Другими словами, это каркас алгоритма, который хорошо подходит для библиотек (в фреймворках, например). Пользователь
просто реализует уточняющие методы, а суперкласс делает всю основную работу.

Это простой способ изолировать логику в конкретные классы и уменьшить копипаст, поэтому вы повсеместно встретите его в
том или ином виде.

## Пример

Требуется для реализации:

1. Абстрактный класс AbstractClass, реализующий Template Method, который описывает порядок действий;
2. Класс ConcreteClass, реализующий изменяемые действия.

## Применимость

### Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.

    Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в базовом классе.

### Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.

    Паттерн шаблонный метод предлагает создать для похожих классов общий суперкласс и оформить в нём главный алгоритм в виде шагов. Отличающиеся шаги можно переопределить в подклассах.

    Это позволит убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.

## Шаги реализации

1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Прикиньте, какие шаги будут стандартными для всех
   вариаций алгоритма, а какие — изменяющимися.

2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов
   алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык
   программирования это позволяет).

3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. Вы можете сделать эти методы абстрактными или
   добавить какую-то реализацию по умолчанию. В первом случае все подклассы должны будут реализовать эти методы, а во
   втором — только если реализация шага в подклассе отличается от стандартной версии.

4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и
   после всех шагов.

5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.

## Преимущества и недостатки

    + Облегчает повторное использование кода.

    - Вы жёстко ограничены скелетом существующего алгоритма.
    - Вы можете нарушить принцип подстановки Барбары Лисков, изменяя базовое поведение одного из шагов алгоритма через подкласс.
    - С ростом количества шагов шаблонный метод становится слишком сложно поддерживать.

## Отношения с другими паттернами

1. Фабричный метод можно рассматривать как частный случай Шаблонного метода. Кроме того, Фабричный метод нередко бывает
   частью большого класса с Шаблонными методами.

2. Шаблонный метод использует наследование, чтобы расширять части алгоритма. Стратегия использует делегирование, чтобы
   изменять выполняемые алгоритмы на лету. Шаблонный метод работает на уровне классов. Стратегия позволяет менять логику
   отдельных объектов.



