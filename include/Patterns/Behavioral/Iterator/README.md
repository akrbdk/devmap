
## Итератор (Iterator)

Паттерн Iterator относится к поведенческим паттернам уровня объекта.

Паттерн Iterator предоставляет механизм обхода коллекций объектов не раскрывая их внутреннего представления.

Зачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой. 


## Примечание

Стандартная библиотека PHP SPL определяет интерфейс Iterator, который хорошо подходит для данных целей. Также вам может понадобиться реализовать интерфейс Countable, чтобы разрешить вызывать count($object) в вашем листаемом объекте.

## Пример

Iterator представляет собой общий интерфейс, позволяющий реализовать произвольную логику итераций. Обычно итераторы имеют набор следующих методов:

Метод Current() возвращает текущий элемент коллекции;
Метод Next() перемещает указатель на следующий элемент коллекции и возвращает его;
Метод HasNext() проверяет доступность следующего элемента.

Требуется для реализации:

1. Интерфейс Iterator описывающий набор методов для доступа к коллекции;
2. Класс ConcreteIterator, реализующий интерфейс Iterator. Следит за позицией текущего элемента при переборе коллекции (Aggregate).;
3. Интерфейс Aggregate описывающий набор методов коллекции объектов;
4. Класс ConcreteAggregate, реализующий интерфейс Aggregate и хранящий в себе элементы коллекции.

## Применимость

### Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).

    Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

### Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.

    Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.

### Когда вам хочется иметь единый интерфейс обхода различных структур данных.

    Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.


## Шаги реализации

1. Создайте общий интерфейс итераторов. Обязательный минимум — это операция получения следующего элемента коллекции. Но для удобства можно предусмотреть и другое. Например, методы для получения предыдущего элемента, текущей позиции, проверки окончания обхода и прочие.

2. Создайте интерфейс коллекции и опишите в нём метод получения итератора. Важно, чтобы сигнатура метода возвращала общий интерфейс итераторов, а не один из конкретных итераторов.

3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор.

4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. Коллекция должна передавать ссылку на собственный объект в конструктор итератора.

5. В клиентском коде и в классах коллекций не должно остаться кода обхода элементов. Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

## Преимущества и недостатки

    + Упрощает классы хранения данных.
    + Позволяет реализовать различные способы обхода структуры данных.
    + Позволяет одновременно перемещаться по структуре данных в разные стороны.

    - Не оправдан, если можно обойтись простым циклом.

## Отношения с другими паттернами

1. Вы можете обходить дерево `Компоновщика`, используя `Итератор`.

2. `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им итераторы.

3. `Снимок` можно использовать вместе с `Итератором`, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.

4. `Посетитель` можно использовать совместно с `Итератором`. `Итератор` будет отвечать за обход структуры данных, а `Посетитель` — за выполнение действий над каждым её компонентом.

