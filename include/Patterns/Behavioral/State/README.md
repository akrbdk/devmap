## Состояние (State)

Паттерн State относится к поведенческим паттернам уровня объекта.

Паттерн State позволяет объекту изменять свое поведение в зависимости от внутреннего состояния и является
объектно-ориентированной реализацией конечного автомата. Поведение объекта изменяется на столько, что создается
впечатление, что изменился класс объекта.

Паттерн должен применятся, когда поведение объекта зависит от его состояния и оно должно изменяться во время выполнения
программы при условии того, что состояний достаточно много и использовать для этого условные операторы разбросаные по
коду достаточно затруднительно.

## Пример

Требуется для реализации:

1. Класс Context, представляет собой объектно-ориентированное представление конечного автомата;
2. Абстрактный класс State, определяющий интерфейс различных состояний;
3. Класс ConcreteStateA, реализует одно из поведений ассоциированное с определенным состоянием;
4. Класс ConcreteStateB, реализует одно из поведений ассоциированное с определенным состоянием.

## Применимость

### Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.

    Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть своей работы. Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.

### Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.

    Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.

### Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.

    Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании. Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь дублирующий код.

## Шаги реализации

1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже
   есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.

2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
   Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.

3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с
   конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во
   всех классах состояний.

При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или
методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.

Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете
сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста. Но
последний способ доступен только в некоторых языках программирования (например, Java, C#).

4. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.

5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов
   объекта-состояния.

6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо
   внутри классов конкретных состояний.

## Преимущества и недостатки

    + Избавляет от множества больших условных операторов машины состояний.
    + Концентрирует в одном месте код, связанный с определённым состоянием.
    + Упрощает код контекста.

    - Может неоправданно усложнить код, если состояний мало и они редко меняются.

## Отношения с другими паттернами

1. Мост, Стратегия и Состояние (а также слегка и Адаптер) имеют схожие структуры классов — все они построены на принципе
   «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные
   проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем,
   которые привели к данному решению.

2. Состояние можно рассматривать как надстройку над Стратегией. Оба паттерна используют композицию, чтобы менять
   поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в Стратегии эти объекты не знают
   друг о друге и никак не связаны. В Состоянии сами конкретные состояния могут переключать контекст.



