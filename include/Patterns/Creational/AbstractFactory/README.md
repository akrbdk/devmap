
## Абстрактная фабрика (Abstract Factory)

Паттерн Abstract Factory относится к порождающим паттернам уровня объекта.

Паттерн Abstract Factory предоставляет общий интерфейс для создания семейства взаимосвязанных объектов. 
Это позволяет отделить функциональность системы от внутренней реализации каждого класса, а обращение к этим классам 
становится возможным через абстрактные интерфейсы.

В общем виде абстрактная фабрика выглядит следующим образом. Для каждого из семейств объектов, создается конкретная фабрика 
(наследник абстрактной), посредством которой создаются продукты этого семейства.

### Пример

Есть две фабрики по производству газировки, Кока-Кола и Пепси. Эти фабрики выпускают семейство продуктов (объектов) - 
бутылка, крышка, этикетка, жидкость. Каждая из этих фабрик выпускает продукты, которые взаимодействуют между собой и не могут 
жить отдельно друг от друга. Фабрика Кока-Кола не может поставлять клиентам пустые бутылки.

Что бы реализовать простое создание семейства объектов, должен быть интерфейс, по которому работает фабрика, так же фабрика должна 
выпускать продукты с определенным интерфейсом. Например, бутылки обеих компаний обладают одним интерфейсом - у них есть горлышко 
через которое они наполняются жидкостью, так же мы можем узнать объем бутылок. Дальше бутылки могут отличаться по форме, объему или 
материалу, нас это не касается, нам нужно только знать, куда наливать жидкость, а так же, сколько этой жидкости нужно.

Требуется для реализации:

1. Класс абстрактной фабрики AbstractFactory, описывающий общий интерфейс фабрики, от которой будет наследоваться каждая конкретная фабрика;
2. Класс абстрактного продукта AbstractProduct, описывающий общий интерфейс продукта, от которого будет наследоваться каждый конкретный продукт;
3. Класс конкретной фабрики Factory;
4. Класс конкретного продукта ProductA.
5. Класс конкретного продукта ProductB.

## Пример из реальной жизни

    В этом примере паттерн Абстрактная фабрика предоставляет инфраструктуру для создания нескольких разновидностей шаблонов 
    для одних и тех же элементов веб-страницы.
    
    Чтобы веб-приложение могло поддерживать сразу несколько разных движков рендеринга страниц, его классы должны работать с 
    шаблонами только через интерфейсы, не привязываясь к конкретным классам. Чтобы этого достичь, объекты приложения не должны 
    создавать шаблоны напрямую, а поручать создание специальным объектам-фабрикам, с которыми тоже надо работать через а
    бстрактный интерфейс.
    
    Благодаря этому, вы можете подать в приложение фабрику, соответствующую одному из движков рендеринга, зная, что с этого 
    момента, все шаблоны будут порождаться именно этой фабрикой, и будут соответствовать движку рендеринга этой фабрики. 
    Если вы захотите сменить движок рендеринга, то всё что нужно будет сделать — это подать в приложение объект фабрики другого 
    типа и ничего при этом не сломается.

### Применимость

- Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.
- Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.
- Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.
- В хорошей программе каждый класс отвечает только за одну вещь. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

### Шаги реализации

    1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
    2. Сведите все вариации продуктов к общим интерфейсам.
    3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
    4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
    5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
    6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

### Преимущества и недостатки

    + Гарантирует сочетаемость создаваемых продуктов.
    + Избавляет клиентский код от привязки к конкретным классам продуктов.
    + Выделяет код производства продуктов в одно место, упрощая поддержку кода.
    + Упрощает добавление новых продуктов в программу.
    + Реализует принцип открытости/закрытости.

    - Усложняет код программы из-за введения множества дополнительных классов.
    - Требует наличия всех типов продуктов в каждой вариации.

Отношения с другими паттернами

- Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).

- `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.

- Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.

- `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.

- `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.

- `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

