## Фабричный метод (FactoryMethod)

Паттерн Factory Method относится к порождающим паттернам уровня класса и сфокусирован только на отношениях между
классами.

Паттерн Factory Method полезен, когда система должна оставаться легко расширяемой путем добавления объектов новых типов.
Этот паттерн является основой для всех порождающих паттернов и может легко трансформироваться под нужды системы. По
этому, если перед разработчиком стоят не четкие требования для продукта или не ясен способ организации взаимодействия
между продуктами, то для начала можно воспользоваться паттерном Factory Method, пока полностью не сформируются все
требования.

Паттерн Factory Method применяется для создания объектов с определенным интерфейсом, реализации которого предоставляются
потомками. Другими словами, есть базовый абстрактный класс фабрики, который говорит, что каждая его наследующая фабрика
должна реализовать такой-то метод для создания своих продуктов.

Реализация фабричного метода может быть разной, в большинстве случаем это зависит от языка реализации. Это может быть
полиморфизм или параметризированный метод.

Factory Method отличается от Abstract Factory, тем, что Abstract Factory производит семейство объектов, эти объекты
разные, обладают разными интерфейсами, но взаимодействуют между собой. В то время как Factory Method производит продукты
придерживающиеся одного интерфейса и эти продукты не связаны между собой, не вступают во взаимодействие.

Этот паттерн является «настоящим» Шаблоном Проектирования, потому что он следует «Принципу инверсии зависимостей» также
известному как «D» в S.O.L.I.D.

## Пример

К нам приходят файлы трех расширений .txt, .png, .doc. В зависимости от расширения файла мы должны сохранять его в одном
из каталогов /file/txt/, /file/png/ и /file/doc/. Значит, у нас будет файловая фабрика с параметризированным фабричным
методом, принимающим путь к файлу, который нам нужно сохранить в одном из каталогов. Этот фабричный метод возвращает нам
объект, используя который мы можем манипулировать с нашим файлом (сохранить, посмотреть тип и каталог для сохранения).
Заметьте, мы никак не указываем какой экземпляр объекта-продукта нам нужно получить, это делает фабричный метод путем
определения расширения файла и на его основе выбора подходящего класса продукта. Тем самым, если наша система будет
расширяться и доступных расширений файлов станет, например 25, то нам всего лишь нужно будет изменить фабричный метод и
реализовать классы продуктов.

Требуется для реализации:

1. Базовый абстрактный класс Creator, описывающий интерфейс, который должна реализовать конкретная фабрика для
   производства продуктов. Этот базовый класс описывает фабричный метод.
2. Базовый класс Product, описывающий интерфейс продукта, который возвращает фабрика. Все продукты возвращаемые фабрикой
   должны придерживаться единого интерфейса.
3. Класс конкретной фабрики по производству продуктов ConcreteCreator. Этот класс должен реализовать фабричный метод;
4. Класс реального продукта ConcreteProductA;
5. Класс реального продукта ConcreteProductB;
6. Класс реального продукта ConcreteProductC.

## Применимость

### Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.

    Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.

    Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, 
    вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

### Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.

    Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?

    Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.
    
    Например, вы используете готовый UI-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных 
    прямоугольных. Вы создаёте класс `RoundButton`. Но как сказать главному классу фреймворка `UIFramework`, чтобы он теперь создавал круглые кнопки, вместо стандартных?
    
    Для этого вы создаёте подкласс `UIWithRoundButtons` из базового класса фреймворка, переопределяете в нём метод создания кнопки 
    (а-ля `createButton`) и вписываете туда создание своего класса кнопок. Затем используете `UIWithRoundButtons` вместо стандартного `UIFramework`.

## Шаги реализации

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий
   интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами
   фабричного метода, перенося в него код создания различных продуктов. В фабричный метод, возможно, придётся добавить
   несколько параметров, контролирующих, какой из продуктов нужно создать. На этом этапе фабричный метод, скорее всего,
   будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не
   волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания
   соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении
   параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось —
   не беда, это будет его реализацией по умолчанию.

## Преимущества и недостатки

    + Избавляет класс от привязки к конкретным классам продуктов.
    + Выделяет код производства продуктов в одно место, упрощая поддержку кода.
    + Упрощает добавление новых продуктов в программу.
    + Реализует принцип открытости/закрытости.

    - Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.

## Отношения с другими паттернами

1. Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и
   эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
2. Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на
   основе `Прототипа`.
3. `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им
   итераторы.
4. `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот,
   построен на наследовании, но не требует сложной инициализации.
5. `Фабричный метод` можно рассматривать как частный случай `Шаблонного метода`. Кроме того, `Фабричный метод` нередко
   бывает частью большого класса с `Шаблонными методами`.


