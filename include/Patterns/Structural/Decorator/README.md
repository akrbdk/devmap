
## Декоратор (Decorator)

Паттерн Decorator относится к структурным паттернам уровня объекта.

Паттерн Decorator используется для расширения функциональности объектов путем динамического добавления объекту новых возможностей. При реализации паттерна используется отношение композиции.

Сущность работы декоратора заключается в обёртывании готового объекта новым функционалом, при этом весь оригинальный интерфейс объекта остается доступным, путем передачи декоратором всех запросов обернутому объекту.

## Пример

Требуется для реализации:

1. Базовый абстрактный класс Component который предоставляет интерфейс для класса декоратора и компонента;
2. Класс ConcreteDecorator, реализующий интерфейс Component и перезагружающий все методы компонента, по необходимости к ним добавляется функционал;
3. Класс ConcreteComponent реализующий интерфейс Component и который будет обернут декоратором.

При такой структуре нам не важно является ли компонент декоратором или конкретной реализацией, так как интерфейс у них совпадает, и мы можем делать цепочки декораторов. Тем самым динамически менять состояние и поведение объекта.

Я слышал пример с Калсоном и мне он очень понравился. У нас есть Карлсон, мы на него одеваем комбинезон тем самым меняя его состояние, потом на штаны одеваем пропеллер тем самым меняем поведение. Пропеллер в зависимости от ситуации можно снять, изменив поведение на обратное или можно одеть другой комбинезон с другими свойствами.

## Применимость

### Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.

    Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

### Когда нельзя расширить обязанности объекта с помощью наследования.

    Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

## Шаги реализации

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.

2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.

3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.

4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.

5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.

6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.

7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

## Преимущества и недостатки

    + Большая гибкость, чем у наследования.
    + Позволяет добавлять обязанности на лету.
    + Можно добавлять несколько новых обязанностей сразу.
    + Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

    - Трудно конфигурировать многократно обёрнутые объекты.
    - Обилие крошечных классов.

## Отношения с другими паттернами

1. `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.

2. `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.

3. `Цепочка обязанностей` и `Декоратор` имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.

4. Обработчики в `Цепочке обязанностей` могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны `Декораторы` расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.

5. `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.

6. `Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.

7. Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.

8. Архитектура, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

9. `Стратегия` меняет поведение объекта «изнутри», а `Декоратор` изменяет его «снаружи».

10. `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.



