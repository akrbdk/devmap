
## Адаптер (Adapter)

Паттерн Adapter относится к структурным паттернам уровня класса.

Часто в новом проекте разработчики хотят повторно использовать уже существующий код. Например, имеющиеся классы могут обладать нужной
функциональностью и иметь при этом несовместимые интерфейсы. В таких случаях следует использовать паттерн Adapter.

Смысл работы этого паттерна в том, что если у вас есть класс и его интерфейс не совместим с кодом вашей системы, то что бы разрешить 
этот конфликт, мы не изменяем код этого класса, а пишем для него адаптер. Другими словами Adapter адаптирует существующий код к 
требуемому интерфейсу (является переходником).

## Пример

Требуется для реализации:

1. Интерфейс ITarget, описывающий целевой интерфейс (тот интерфейс с которым наша система хотела бы работать);
2. Класс Adaptee, который наша система должна адаптировать под себя;
3. Класс Adapter, адаптер реализующий целевой интерфейс.

## Применимость

### Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

    Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

### Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.

    Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.

    Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн Декоратор.


## Шаги реализации

1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
    полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
    один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.

2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.

3. Создайте класс адаптера, реализовав этот интерфейс.

4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.

5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.

6.  Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

## Преимущества и недостатки

    + Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

    - Усложняет код программы из-за введения дополнительных классов.

## Отношения с другими паттернами

1. `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.

2. `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.

3. `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.

4. `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.

5. `Мост`, `Стратегия` и `Состояние` (а также слегка и Ада`птер) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.


