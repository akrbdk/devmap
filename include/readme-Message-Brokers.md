# Readme


### RabbitMQ [&uarr;](#Readme)

`RabbitMQ` – это распределенный брокер сообщений с открытым исходным кодом, который обеспечивает эффективную доставку
сообщений в рамках сложных сценариев маршрутизации. Этот инструмент называется «распределенным», потому что обычно
работает как кластер узлов, где очереди распределяются (реплицируются) по узлам для обеспечения высокой доступности и
отказоустойчивости.

По умолчанию в `RabbitMQ` используется протокол `AMQP 0.9.1`, также существуют расширения для поддержки дополнительных
протоколов: `AMQP 1.0, HTTP, STOMP и MQTT`. `RabbitMQ` официально поддерживает `Elixir, Go, Java, JavaScript, .NET, PHP,
Python, Ruby, Objective-C, Spring и Swift`. Пользователям доступны различные инструменты разработки и клиенты,
использующие расширения сообщества.

Разработчики используют `RabbitMQ` для обработки высокопроизводительных и надежных фоновых заданий, а также для интеграции
и взаимодействия внутри приложений и между ними. Инструмент применяется для выполнения сложной маршрутизации к
консьюмерам и интеграции нескольких приложений и служб с нетривиальной логикой маршрутизации.

`RabbitMQ` идеально подходит для веб-серверов, которым требуется быстрый запрос-ответ. Этот инструмент распределяет
нагрузку между рабочими приложениями при высокой нагрузке (более 20 000 сообщений в секунду) и может обрабатывать
фоновые задания или длительные задачи, такие как преобразование PDF, сканирование файлов или масштабирование
изображений.

### Kafka [&uarr;](#Readme)

`Apache Kafka` – это распределенная платформа потоковой передачи событий с открытым исходным кодом, обеспечивающая высокую
пропускную способность. Написанная на Java и Scala, Kafka представляет собой шину сообщений системы Pub/Sub,
ориентированную на потоки и воспроизведение данных с высокой интенсивностью. Кафка не полагается на очередь, а добавляет
сообщения в журнал и оставляет их там до достижения предела хранения или тех пор, пока консьюмер не прочитает эти
сообщения.

`Apache Kafka` лучше всего подходит для потоковой передачи от А к Б без сложной маршрутизации, но с максимальной
пропускной способностью. Инструмент отлично справляется с event sourcing, потоковой обработкой и моделированием
изменений в системе в качестве последовательности событий. Кафку также можно использовать для обработки данных при
многоэтапной конвейерной обработке.

`Kafka` станет отличным решением, если вам нужен фреймворк для хранения, чтения, повторного чтения и анализа потоковых
данных. Ее сильная сторона – обработка и анализ данных в реальном времени. Инструмент идеально подходит для постоянного
хранения сообщений или для регулярно проверяемых систем.

### Основные отличия Apache Kafka и RabbitMQ [&uarr;](#Readme)

- `Поток данных`. RabbitMQ использует определенный ограниченный поток данных. Продюсер создает и отправляет сообщения, а консьюмер их принимает. Apache Kafka использует неограниченный поток данных, при этом пары «ключ-значение» непрерывно передаются в назначенную тему.

- `Использование данных`. RabbitMQ отлично подходит для запросов пользователей и транзакционных данных, таких как создание и размещение заказов. Кафка лучше справляется с операционными данными, такими как технологические процессы, статистика аудита и сбора данных, активность системы.

- `Обмен сообщениями`. RabbitMQ отправляет пользователям сообщения, которые удаляются из очереди после их обработки и подтверждения. Кафка – это журнал. Он использует непрерывные цепочки сообщений, которые сохраняются в очереди до истечения срока хранения.

- `Модель проектирования`. RabbitMQ использует модель умный брокер/тупой консьюмер. Брокер последовательно доставляет сообщения консьюмерам и отслеживает их статус. Apache Kafka использует модель тупого брокера/умного консьюмера. Этот инструмент не отслеживает сообщения, которые прочитал каждый пользователь. Кафка запоминает только непрочитанные сообщения, сохраняя их в течение установленного периода времени. Консьюмеры должны самостоятельно следить за своей позицией в каждом журнале.

- `Топология`. RabbitMQ использует топологию обмена очереди: сообщения отправляются на обмен, откуда затем рассылаются в различные привязки очередей для использования консьюмерами. Кафка использует топологию Publish/Subscribe, отправляя сообщения через поток в соответствующие топики, которые затем потребляются пользователями в разных авторизованных группах.
