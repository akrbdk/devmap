# Readme

#### Список ссылок

- [Статический анализ кода](https://doka.guide/tools/static-analysis/)
- [Что такое код-ревью](https://doka.guide/tools/code-review/)
- [Comments that are easy to grok and grep](https://conventionalcomments.org/)
- [Что такое технический долг](https://doka.guide/js/technical-debt/)
- [PSR Стандарты](https://habr.com/ru/post/458484/)
- [PSR-1: Basic Coding Standard](https://www.php-fig.org/psr/psr-1/)
- [PSR-4: Autoloader](https://www.php-fig.org/psr/psr-4/)
- [PSR-12: Extended Coding Style](https://www.php-fig.org/psr/psr-12/)


### Composer [&uarr;](#Readme)

Composer — менеджер пакетов для PHP.

Composer, менеджер зависимостей для PHP, был выпущен около 10 лет назад, а недавно опубликовали новую версию, 2.0. За
эти годы Composer получил множество новых функций и не отставал от стандартов PHP. Вторая версия совместима со старыми
проектами, но привнесет еще несколько замечательных новых функций.

Список улучшений:

#### Ускорение и оптимизация

В этом релизе была улучшена производительность. Теперь он не учитывает уже установленные пакеты, в результате обновление проходит намного быстрее. 
Также улучшили работу с памятью и процессором.

Команда установки стала умнее. Теперь она не изменяет папку vendor до тех пор, пока не гарантирует, что все пакеты установлены. 
Это позволяет избежать потери времени на их удаление в случае ошибок во время процесса.

Одной из лучших функций, для меня, стала параллельная загрузка, которая теперь поддерживается из коробки, и нам не нужно устанавливать 
дополнительные пакеты, как hirak/prestissimo, чтобы это работало.

#### Поддержка оффлайн

Composer представил возможность использовать его в оффлайн режиме. Это может быть интересно для бенчмарков или при возникновении проблем с 
подключением к интернету

#### Поддержка --dry-run для “require” и “remove”

Эта опция уже была доступна при обновлении пакетов (composer update --dry-run. Она позволяет нам увидеть, что произойдет при запуске команды, 
просто отображая данные в терминале, без реальных изменений в вашем проекте или папке vendor.

Composer 2.* дает возможность использовать опцию с composer require и composer remove что делает нашу жизнь проще

#### Предотвращение проблем при работе от root

При выполнении команд от пользователя root теперь требуется подтверждение, чтобы предотвратить наши ошибки.

#### Канонические репозитории

Эта функция решает определенную проблему, с которой сталкиваются несколько разработчиков при использовании одного и того же пакета в разных репозиториях. Composer 1.0 следовал определенному порядку при установке/обновлении своих пакетов. Он начал искать пакеты в своем списке репозиториев до тех пор, пока пакет не будет найден (также последняя версия).

Иногда это было не совсем ожидаемое поведение при работе с различными версиями пакетов в других репозиториях (используемых одним и тем же проектом). Представьте себе, что иногда вы хотите загрузить пакет из своего частного репозитория, а не из packagist, в котором есть пакет с тем же именем.

По умолчанию, в composer 2.x, все репозитории являются каноническими. Composer 1.x рассматривал все репозитории как неканонические, и для того, чтобы поменять поведение вручную, вы можете сделать

    {
        "repositories": [
            {
                "type": "composer",
                "url": "https://example.org",
                "canonical": false
            }
        ]
    }

Игнорировать определенное требование платформы

    Если по какой-то причине вы хотите проигнорировать какое-либо определенное требование платформы, вы можете просто запустить команду: composer install --ignore-platform-req php

    Она пропустит требование для PHP или конкретной версии. Если вы собираетесь игнорировать все требования, вам следует использовать команду, уже доступную в предыдущих версиях --ignore-platform-reqs


### Стандарты написания кода [&uarr;](#Readme)

### Восемь общих правил

Существуют правила, которые подойдут для написания кода на любом языке программирования. Только следование им уже
повысит качество вашего кода.

- Придумывайте понятные и читаемые названия. Избегайте русских слов в латинской транскрипции. Только английские слова, обозначающие суть.
- Делайте отступы на каждом уровне и отделяйте логические блоки пустой строкой.
- Сокращайте вложенность кода и убирайте дублирование.
- Контролируйте длину. Рекомендуем для функций не более 20 строк, для метода не более 50 строк, для класса не более 300 строк, для файла — не более 1000 строк. Также ограничивайте длину одной строки до видимого значения на экране. Мягкое ограничение составляет 120 символов.
- Комментируйте и документируйте код. Это позволит зафиксировать всю необходимую информацию.
- Используйте рефакторинг. Следуйте принципу «рефакторинг — раньше и рефакторинг — чаще». Советуем также прочитать книгу «Рефакторинг. Улучшение проекта существующего кода» Мартина Фаулера.
- Работайте в системе контроля версий, например, Git. Это бесплатно и удобно. Обучиться работать в ней можно за 11 занятий на видеокурсе «Git. Быстрый старт».
- Изучайте Open Source код. Вы сможете увидеть, как пишут ведущие разработчики и воспользоваться лучшими практиками в программировании

### Статический анализ кода

Часто можно сказать, насколько код программы корректен, даже не запуская её. Процесс исследования исходного кода без
запуска называют статическим анализом или линтингом, а программу, которая это делает — статическим анализатором или
линтером.

Линтер — это программа, которая разбирает исходный код на стандартизированные кусочки, а потом даёт эти кусочки на
проверку специальным плагинам. Плагин получает разобранный участок кода и проверяет его на корректность по ряду правил,
которые определены в этом плагине.

Самый популярный линтер для JavaScript — это ESLint. Он находит участки кода, которые могут потенциально привести к
ошибкам, и сообщает об этом.

Чтобы воспользоваться ESLint, нужно установить его через менеджер зависимостей в папке проекта.

    npm install --save-dev eslint

После установки нужно инициализировать конфигурационный файл .eslintrc.json.

    npx eslint --init

В созданный файл можно добавлять правила, по которым линтер будет работать. Обычно используют стандартную конфигурацию,
поверх которой добавляют правила, подходящие для конкретного проекта.

    { // ...
    "extends": "eslint:recommended", // ... }

Теперь можно добавить в package.json новый скрипт, который будет запускать статический анализ.

    { // ...
    "scripts": {
    "lint": "eslint ./**/*.js"
    } // ... }

После запуска линтера командой `npm run lint`, в консоли появится результат его работы.

На самом деле, статически проанализировать можно почти любой язык программирования. Поэтому, при разработке
веб-приложений часто не останавливаются на использовании ESLint, а добавляют ещё Stylelint — линтер для стилей. Он умеет
работать не только с CSS, но и почти с любым языком описания стилей, например, CSS-in-JS, SCSS или Stylus.

Автоматический запуск:

- запускают линтер на серверах и показывают результат программисту, этот подход называют CI, он широко применяется в индустрии;
- добавляют автоматический вызов линтера при создании нового коммита в репозитории;
- интегрируют статический анализ в среду разработки, так можно получать рекомендации прямо во время написания кода и сразу на них реагировать.

### PSR

`PSR (PHP Standards Recommendations)` — описывает общие концепции, которые уже были проверены и отработаны.

Список PSR стандартов расширяется новыми, а сами стандарты делятся на категории:

- Автозагрузка, 
- Интерфейсы, 
- HTTP
- Стиль кодирования

каждому из которых присваивается определенный статус:
    
- Принят 
- Устаревший 
- Черновик
- Заброшенный

#### Стиль кодирования:

Цель следующих PSR стандартов уменьшить когнитивное искажение при чтении кода от разных авторов.

- PSR-1: Basic Coding Standard
- PSR-2 — Coding Style Guide Устарел
- PSR-12: Extended Coding Style Guide 

Описанные выше спецификации достаточно объемные, поэтому мы рассмотрим только базовые из PSR-1:

- Использование только тэгов <?php и <?=
- Только UTF-8 без BOM для php кода
- Не стоит мешать разный функционал в одном файле (1 файл = 1 класс)
- Пространство имен и классы должны следовать [PSR-0, PSR-4]
- Классы объявляются в `StudlyCase`
- Константы объявляются в ТАКОМ_ВИДЕ
- Методы объявляются в `camelCase`

На самом деле, нет смысла помнить про кажный пункт о переносе скобки, пробеле, табе и т.п., так как существует различный
функционал, который позволяет автоматически проверить и отформатировать кодовую базу по стандарту PSR-2/PSR-12:

- Ручной режим: можно использовать reformat code в phpStorm.
- Более продвинутый вариант: использовать какой-нибуть кодснифер, например PHP CS Fixer (часто используется в CI, чтобы не принимать коммиты с неотформатированным кодом).

### Код-ревью

Код-ревью — это область, где особенно ярко проявляются софт-скиллы инженеров. Провести хорошее код-ревью сложнее, чем
написать хороший код.

Отправка изменений на код-ревью происходит через пул-реквесты. Для прохождения код-ревью нужно получить одобрение одного или нескольких коллег. 
Способ выбора коллег для проведения ревью зависит от процессов внутри компании.

`Пул-реквест (PR)` — это предложение слить изменения в ветке разработчика с другой веткой. Иногда их называют мёрж-реквестами (MR).

#### Conventional comments

Conventional comments предлагает формат, где сообщение описывается как:

    <label> [decorations]: <subject>
    [discussion]

- `label` - тип комментария;
- `subject` - основная мысль комментария;
- `decorations` (опционально) - дополнительные лэйблы для комментария. Они окружены скобками;
- `discussion` (опционально) - здесь содержатся подтверждающие заявления, контекст, рассуждения и все остальное, чтобы помочь сообщить "почему" и "последующие шаги" для разрешения замечания;

Например:

    question (non-blocking): На этом этапе имеет значение, какой поток выиграл?
    Может быть, чтобы предотвратить состояние гонки, мы должны продолжать зацикливаться, пока все они не выиграют?

Настоятельно рекомендуется использовать следующие лэйблы:

- `praise` - «Похвала» подчёркивает что-то положительное. Попробуйте оставить хотя бы один такой комментарий. Не оставляйте ложных похвал (которые на самом деле могут нанести вред).
- `nitpick` - «Придирки» - это небольшие, но необходимые изменения. Придирчивые комментарии значительно помогают направить внимание читателя на комментарии, требующие большего внимания.
- `suggestion` - «Предложения» предоставляют способы по совершенствованию в определённой теме. Важно быть предельно ясным в том, что предлагается и почему именно это улучшение. Рассмотрите возможность использовать блокирующие и не блокирующие декорации для последующего информирования о ваших намерениях.
- `issue` - «Проблемы» высвечивают конкретные трудности рассматриваемого вопроса. Если вы не уверены, существует проблема или нет - рассмотрите возможность оставить question.
- `question` - «Вопросы» допустимы, если у вас есть потенциальная проблема, но не уверены уместна она или нет. Обращение к автору с просьбой о разъяснении или расследовании может привести к быстрому урегулированию этого вопроса.
- `thought` - «Мысли» представляют собой идею, которая всплыла в процессе ревью. Эти замечания по своей природе не блокируют, но они чрезвычайно ценны и могут привести к более целенаправленным предложениям и возможностям наставничества.
- `chore` - «Рутинная работа» - это небольшие задачи которые необходимо выполнить до того как пулреквест (или другая форма ревью) «официально» будут приняты. Обычно в таких комментариях упоминаются какие-то общие процессы. Постарайтесь оставить ссылку в описании на процесс, чтобы автор мог понять как именно выполнять рутинную работу.

Декорации дают дополнительный контекст для комментария:

- `(non-blocking)` - комментарий с такой декорацией не должен препятствовать принятию рассматриваемого пулреквеста. Это полезно для команд, которые рассматривают блокирование комментариев по умолчанию.
- `(blocking)` - комментарий с такой декорацией должен препятствовать принятию рассматриваемого вопроса до тех пор, пока он не будет решён. Это полезно для команд, которые считают, что комментарии не блокируются по умолчанию.
- `(if-minor)` - эта декорация даёт автору некоторую свободу действий, которая заключается в том, что он может разрешить комментарий только в том случае, если изменения окажутся незначительными или тривиальными.


### Шаги по оптимизации сайта [&uarr;](#Readme)

#### Бэкенд и запросы к бд:

- анализируем лог sql запросов 
- Убираем запросы в цикле
- В запрашиваемых данных из БД в массиве select оставляем только нужные.
- Если время запроса превышает 0.001 секунду - оптимизируем запрос, думаем над созданием индексов
- Проверяем, настроено ли кэширование и параметры, от которого оно зависит.

#### Конфигурация и производительность сервера:

- Версия Mysql должна быть не ниже выше 5.7, версия PHP - не ниже 7.0
- Желательно наличие акселератора PHP (OPcache, XCache, APC и другого). Лучше всего OPcache

#### Фронтенд - работа со скриптами, стилями, статикой, изображениями и пр:

Проверяем сайт через:

- https://developers.google.com/speed/pagespeed/insights/ - оценка для мобильных устройств и декстопа должна находится в зелёной зоне
- https://tools.pingdom.com/ - вес страницы не должен превышать 2-3 Mb
- В консоли Chrome в панели audits показатели должны быть выше 60%

Что должно быть реализовано:

- Статическая информация должна кэшироваться браузером (проверить настройки в .htaccess)
- Для загрузки картинок, не входящих в первый экран, обязательно использовать lazy-load. Это так же касается вторых, третьих и тд картинок на слайдерах 
- Картинки должны быть оптимизированы для веба и отресайзены на нужные размеры
- Использовать для картинок тэг picture
- Минификация / обфускация js скриптов
- Количество подгружаемых на странице js-скриптов должно быть ограничего, т.к. стандартно браузеры могут загружать файлы не более чем в 6-10 потоков с одного хоста. Т.е. работать будет быстрее, если собрать несколько мелких js в один большой, чем загружать 40 маленьких отдельно. 
- Сторонние стандартные библиотеки лучше подгружать извне, т.к. существует вероятность, что браузер пользователя уже их выкачал и закэшировал

### принципиальное различие скриптовых и “обычных” языков [&uarr;](#Other-tasks)

`Скриптовый язык программирования` — язык программирования, разработанный для записи «сценариев»,
последовательностей операций, которые пользователь может выполнять на компьютере.
Интерпертируется с помощью интерпретатора. Имеет динамическую типизацию.

`Интерпретация` — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы
или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).


### htaccess

.htaccess — это локальный конфигурационный файл веб-сервера Apache, который позволяет управлять настройками сайта. В отличие от главного конфигурационного 
файла, который позволяет выполнять настройку веб-сервера в целом, .htaccess даёт возможность изменять настройки для отдельно взятых папок и пользователей.

Действие команд из файла .htaccess распространяется на файлы и подкаталоги, расположенные в одной директории с этим файлом. Если для какой-либо вложенной 
директории нужны иные инструкции, в ней также можно создать файл .htaccess. Если файл .htaccess расположен в корневой директории сервера, его действие 
распространяется на весь сервер, кроме тех директорий, где находится другой файл .htaccess. Лишь модуль mod rewrite имеет свою специфику наследования.

С помощью .htaccess можно частично управлять настройками PHP: Директивы и настройки PHP указываются в файле .htaccess аналогично формату php.ini, 
но перед каждой строкой настроек PHP должно стоять управляющее слово php_value или php_flag.

Также с помощью .htaccess можно выполнить следующие действия:

- настроить 301 редирект с одного домена на другой, для отдельного IP, с http на https и наоборот;
- заблокировать поисковых ботов, которые создают лишнюю нагрузку на СPU сайта;
- настроить сжатие и кэширование для статических файлов;
- защитить админку сайта;

#### mod_rewrite

mod_rewrite — это модуль для веб-сервера Apache, предназначенный для преобразования URL-ов. Модуль использует в своей работе правила, 
которые могут быть описаны как в конфигурации сервера (httpd.conf), так и в файлах .htaccess непосредственно в файловой структуре Вашего сайта.


### Настройка HTTPS с выпуском сертификата

https://rudocs.ispmanager.com/ispmanager-lite/ustanovka-ssl-sertifikata

#### LAMP

LAMP – это аббревиатура от операционной системы Linux, веб-сервера Apache, сервера баз данных MySQL и языка программирования PHP. 
Все четыре из этих технологий имеют открытый исходный код, что означает, что они поддерживаются сообществом и свободно доступны для использования всеми.


### работа по ssh

SSH – это протокол передачи данных, позволяющий производить безопасное и защищённое управление операционной системой и данными.

1. Запусти терминал
2. Введи команду: `ssh u1234567@123.123.123.123`

Где:

- u1234567 — логин учётной записи
- 123.123.123.123 — IP-адрес сервера

### работа с процессами

просмотр списка процессов
убийство процесса
перезапуск служб

### CRON

https://rebrainme.com/blog/linux/kak-poluchit-spisok-zadanij-cron-v-linux/

Чтобы настроить время и интервал запуска скрипта, используется команда crontab:

    crontab -e

Чтобы задать конкретное время исполнения скрипта в cron, используется следующий синтаксис:

    *минута *час *день *месяц *день_недели /путь к файлу

Для обозначения даты и времени используются цифры или * (означает, что нужно выполнять скрипт каждую единицу времени, например, 
если * заменяется час, то скрипт должен запускаться каждый час, если * используется вместо числового обозначения дня — то каждый день). 
Путь до файла следует указывать обязательно полностью, начиная с корневого файла.

Пусть, к примеру, наш скрипт cron запускает каждую неделю в среду в 14 часов 45 минут.

    45 14 * * 3 /usr/local/ping/todo

Отсчет дней недели начинается понедельника, воскресенье считается седьмым или нулевым днем.

Большинство Cron (например, Vixie-Cron — по умолчанию в Debian/Ubuntu, Cronie — по умолчанию в Fedora, Solaris Cron…) предоставляют 
список запланированных заданий cron для текущего пользователя через команду:

    crontab -l

или для другого пользователя через:

    crontab -u username -l

### как описываются права unix - бинарный и целочисленный формат

При создании файла ему всегда назначается основная группа владельца. В дальнейшем владелец может назначить файлу группу, в которую входит сам.

Права доступа включают право на чтение (R__ead), запись (__W__rite) и исполнение (e__X__ecute). Существует три набора прав __rwx для владельца 
файла (U__ser), группы файла (__G__roup) и остальных (__O__ther). Традиционно права записываются в виде строки из трёх троек __rwx. Тройки расположены слева 
направо в порядке ugo. Отсутствующее право помечается прочерком. Набор прав также может быть представлен в виде трёхзначного восьмеричного числа, в 
котором 1 соответствует наличию права, а 0 отсутствию. Например, rwxr-xr-- эквивалентно 7548. Утилита stat позволяет выдать права доступа к файлу 
в восьмеричном виде путём задания формата %a. Например, для каталога /tmp установлены все права для всех и sticky bit:

    $> stat --format=%a /tmp
    1777

Права доступа проверяются в момент выполнения системных вызовов, связанных с доступом к файлам и каталогам, таких как creat(), open(), unlink(), exec(). 
Из трёх наборов прав выбирается тот, который наиболее точно характеризует пользователя, пытающегося получить доступ к файлу. Права для владельца перекрывают 
ему права для группы и прочих, для остальных членов группы права для группы перекрывают права для прочих.


### абсолютный и относительный пути

В операционной системе Linux может быть несколько видов путей к файлу. Давайте рассмотрим какие бывают пути в linux:

- `Полный`, абсолютный путь linux от корня файловой системы - этот путь вы уже видели в примере выше, он начинается от корня "/" и описывает весь путь к файлу;
- `Относительный` путь linux - это путь к файлу относительно текущей папки, такие пути часто вызывают путаницу.
- `Путь относительно домашний папки текущего пользователя`. - путь в файловой системе, только не от корня, а от папки текущего пользователя `~/`
























